<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Slides PHY 480 and PHY 905  Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature">

<title>Slides PHY 480 and PHY 905  Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature</title>


<style type="text/css">
/* bloodish style */

body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em;  color: #8A0808; }
h2 { font-size: 1.6em;  color: #8A0808; }
h3 { font-size: 1.4em;  color: #8A0808; }
h4 { color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


<script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
<script src="http://sagecell.sagemath.org/embedded_sagecell.js"></script>
<link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
<script>
$(function () {
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#mycell',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'Activate'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Evaluate'});
});
</script>

</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Numerical Integration', 2, None, '___sec0'),
              ('Newton-Cotes Quadrature or equal-step methods',
               2,
               None,
               '___sec1'),
              ('Basic philosophy of equal-step methods', 2, None, '___sec2'),
              ('Simple algorithm for equal step methods', 2, None, '___sec3'),
              ('Simple algorithm for equal step methods', 2, None, '___sec4'),
              ("Lagrange's interpolation formula", 2, None, '___sec5'),
              ('Polynomial approximation', 2, None, '___sec6'),
              ('Simplifying the integral', 2, None, '___sec7'),
              ('The trapezoidal rule', 2, None, '___sec8'),
              ('Global error', 2, None, '___sec9'),
              ('Error in the trapezoidal rule', 2, None, '___sec10'),
              ('Algorithm for the trapezoidal rule', 2, None, '___sec11'),
              ('Code example', 2, None, '___sec12'),
              ('Transfer of  function names', 2, None, '___sec13'),
              ('Going back to Python, why?', 2, None, '___sec14'),
              ('Error analysis', 2, None, '___sec15'),
              ('Integrating numerical mathematics with calculus',
               2,
               None,
               '___sec16'),
              ('The rectangle method', 2, None, '___sec17'),
              ('Truncation error for the rectangular rule',
               2,
               None,
               '___sec18'),
              ('Second-order polynomial', 2, None, '___sec19'),
              ("Simpson's rule", 2, None, '___sec20'),
              ('Mathematical expressions for the truncation error',
               2,
               None,
               '___sec21'),
              ("Algorithm for Simpson's rule", 2, None, '___sec22'),
              ('Summary for equal-step methods', 2, None, '___sec23'),
              ("Lagrange's polynomial", 2, None, '___sec24'),
              ('Polynomial approximation', 2, None, '___sec25'),
              ('Gaussian Quadrature', 2, None, '___sec26'),
              ('Gaussian Quadrature, main idea', 2, None, '___sec27'),
              ('Gaussian Quadrature', 2, None, '___sec28'),
              ('Gaussian Quadrature, weight function', 2, None, '___sec29'),
              ('Gaussian Quadrature weights and integration points',
               2,
               None,
               '___sec30'),
              ('Gaussian Quadrature', 2, None, '___sec31'),
              ('Error in Gaussian Quadrature', 2, None, '___sec32'),
              ('Important polynomials in Gaussian Quadrature',
               2,
               None,
               '___sec33'),
              ('Gaussian Quadrature, win-win situation', 2, None, '___sec34'),
              ('Gaussian Quadrature, determining mesh points and weights',
               2,
               None,
               '___sec35'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec36'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec37'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec38'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec39'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec40'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec41'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec42'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec43'),
              ('Orthogonal polynomials, simple code for Legendre polynomials',
               2,
               None,
               '___sec44'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec45'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec46'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec47'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec48'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec49'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec50'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec51'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec52'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec53'),
              ('Application to the case $N=2$', 2, None, '___sec54'),
              ('Application to the case $N=2$', 2, None, '___sec55'),
              ('Application to the case $N=2$', 2, None, '___sec56'),
              ('Application to the case $N=2$', 2, None, '___sec57'),
              ('Application to the case $N=2$', 2, None, '___sec58'),
              ('General integration intervals for Gauss-Legendre',
               2,
               None,
               '___sec59'),
              ('Mapping integration points and weights', 2, None, '___sec60'),
              ('Mapping integration points and weights', 2, None, '___sec61'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec62'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec63'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec64'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec65'),
              ('Other orthogonal polynomials, Hermite polynomials',
               2,
               None,
               '___sec66'),
              ('Other orthogonal polynomials, Hermite polynomials',
               2,
               None,
               '___sec67'),
              ('Demonstration of Gaussian Quadrature', 2, None, '___sec68'),
              ('Demonstration of Gaussian Quadrature, simple program',
               2,
               None,
               '___sec69'),
              ('Demonstration of Gaussian Quadrature', 2, None, '___sec70'),
              ('Demonstration of Gaussian Quadrature', 2, None, '___sec71'),
              ('Comparing methods and using symbolic Python',
               2,
               None,
               '___sec72'),
              ('Treatment of Singular Integrals', 2, None, '___sec73'),
              ('Treatment of Singular Integrals', 2, None, '___sec74'),
              ('Treatment of Singular Integrals, change of variables',
               2,
               None,
               '___sec75'),
              ('Treatment of Singular Integrals, higher-order derivatives',
               2,
               None,
               '___sec76'),
              ('Treatment of Singular Integrals', 2, None, '___sec77'),
              ('Treatment of Singular Integrals', 2, None, '___sec78'),
              ('Treatment of Singular Integrals', 2, None, '___sec79'),
              ('Treatment of Singular Integrals', 2, None, '___sec80'),
              ('Treatment of Singular Integrals', 2, None, '___sec81'),
              ('Treatment of Singular Integrals', 2, None, '___sec82'),
              ('Treatment of Singular Integrals', 2, None, '___sec83'),
              ('Treatment of Singular Integrals', 2, None, '___sec84'),
              ('Hints concerning project 3', 2, None, '___sec85'),
              ('Hints concerning project 3, parts of code',
               2,
               None,
               '___sec86'),
              ('Hints concerning project 3, the function to integrate',
               2,
               None,
               '___sec87'),
              ('Hints concerning project 3, Laguerre polynomials',
               2,
               None,
               '___sec88'),
              ('Hints concerning project 3, Laguerre polynomials, the new integrand',
               2,
               None,
               '___sec89')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- ------------------- main content ---------------------- -->



<center><h1>Slides PHY 480 and PHY 905  Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature</h1></center>  <!-- document title -->

<p>
<!-- author(s): Phil Duxbury, and Morten Hjorth-Jensen -->

<center>
<b>Phil Duxbury</b> [1]
</center>

<center>
<b>Morten Hjorth-Jensen</b> [2, 3]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Department of Physics and Astronomy, Michigan State University</b></center>
<center>[2] <b>Department of Physics, University of Oslo</b></center>
<center>[3] <b>Department of Physics and Astronomy and National Superconducting Cyclotron Laboratory, Michigan State University</b></center>
<br>
<p>
<center><h4>Spring 2016</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec0">Numerical Integration </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Here we will  discuss some of the classical methods for integrating a function. The methods we discuss are  

<ol>
<li> Equal step methods like the trapezoidal, rectangular and Simpson's rule, parts of what are called Newton-Cotes quadrature methods.</li>
<li> Integration approaches   based on Gaussian quadrature.</li> 
</ol>

The latter are more suitable
for the case where the abscissas are not equally spaced. 
We emphasize methods for evaluating few-dimensional (typically up to four dimensions) integrals. Multi-dimensional integrals will be discussed in connection with Monte Carlo methods.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec1">Newton-Cotes Quadrature or equal-step methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The integral 
$$
\begin{equation}
   I=\int_a^bf(x) dx
\label{eq:integraldef}
\end{equation}
$$

has a very simple meaning. The integral is the
area enscribed by the function \( f(x) \) starting from \( x=a \) to  \( x=b \). It is subdivided in several smaller areas whose evaluation is to  be approximated by different techniques. The areas under the curve can for example  be approximated by rectangular boxes or trapezoids.
</div>


<p>
<!-- !split  -->

<h2 id="___sec2">Basic philosophy of equal-step methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In considering equal step  methods, our basic approach is that of approximating
a function \( f(x) \) with a polynomial of at most 
degree \( N-1 \), given \( N \) integration points. If our polynomial is of degree \( 1 \),
the function will be approximated with \( f(x)\approx a_0+a_1x \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec3">Simple algorithm for equal step methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The algorithm for these integration methods  is rather simple, and the number of approximations perhaps  unlimited!

<ul>
<li> Choose a step size \( h=(b-a)/N \)  where \( N \) is the number of steps and \( a \) and \( b \) the lower and upper limits of integration.</li>
<li> With a given step length we rewrite the integral as</li>  
</ul>

$$
\begin{equation*}     
\int_a^bf(x) dx= \int_a^{a+h}f(x)dx + \int_{a+h}^{a+2h}f(x)dx+\dots \int_{b-h}^{b}f(x)dx.
\end{equation*}
$$


<ul>
<li> The strategy then is to find a reliable polynomial approximation   for \( f(x) \) in the various intervals.  Choosing a given approximation for  \( f(x) \), we obtain a specific approximation to the  integral.</li>
<li> With this approximation to \( f(x) \) we perform the integration by computing the integrals over all subintervals.</li>
</ul>
</div>


<p>
<!-- !split  -->

<h2 id="___sec4">Simple algorithm for equal step methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
One possible strategy then is to find a reliable polynomial expansion for \( f(x) \) in the smaller
subintervals. Consider for example evaluating
$$
\begin{equation*}
   \int_a^{a+2h}f(x)dx, 
\end{equation*}
$$

which we rewrite as
$$
\begin{equation}
   \int_a^{a+2h}f(x)dx=
 \int_{x_0-h}^{x_0+h}f(x)dx.
\label{eq:hhint}
\end{equation}
$$

We have chosen a midpoint \( x_0 \) and have defined \( x_0=a+h \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec5">Lagrange's interpolation formula </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Using Lagrange's interpolation formula
$$
\begin{equation*}
   P_N(x)=\sum_{i=0}^{N}\prod_{k\ne i} \frac{x-x_k}{x_i-x_k}y_i,
\end{equation*}
$$

we could attempt to approximate the function \( f(x) \) with a first-order polynomial in \( x \) in the two
sub-intervals \( x\in[x_0-h,x_0] \) and \( x\in[x_0,x_0+h] \). A first order polynomial means simply that 
we have for say the interval  \( x\in[x_0,x_0+h] \)
$$
\begin{equation*}
   f(x)\approx P_1(x)=\frac{x-x_0}{(x_0+h)-x_0}f(x_0+h)+\frac{x-(x_0+h)}{x_0-(x_0+h)}f(x_0),
\end{equation*}
$$

and for the interval  \( x\in[x_0-h,x_0] \)
$$
\begin{equation*}
   f(x)\approx P_1(x)=\frac{x-(x_0-h)}{x_0-(x_0-h)}f(x_0)+\frac{x-x_0}{(x_0-h)-x_0}f(x_0-h).
\end{equation*}
$$
</div>


<p>
<!-- !split  -->

<h2 id="___sec6">Polynomial approximation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Having performed this subdivision and polynomial approximation,
one from \( x_0-h \) to \( x_0 \) and the other from \( x_0 \) to \( x_0+h \),
$$
\begin{equation*}
   \int_a^{a+2h}f(x)dx=\int_{x_0-h}^{x_0}f(x)dx+\int_{x_0}^{x_0+h}f(x)dx,
\end{equation*}
$$

we can easily calculate for example the second integral as
$$
\begin{equation*}
\int_{x_0}^{x_0+h}f(x)dx\approx \int_{x_0}^{x_0+h}\left(\frac{x-x_0}{(x_0+h)-x_0}f(x_0+h)+\frac{x-(x_0+h)}{x_0-(x_0+h)}f(x_0)\right)dx.
\end{equation*}
$$
</div>


<p>
<!-- !split  -->

<h2 id="___sec7">Simplifying the integral </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
This integral can be simplified to
$$
\begin{equation*}
\int_{x_0}^{x_0+h}f(x)dx\approx \int_{x_0}^{x_0+h}\left(\frac{x-x_0}{h}f(x_0+h)-\frac{x-(x_0+h)}{h}f(x_0)\right)dx,
\end{equation*}
$$

resulting in
$$
\begin{equation*}
\int_{x_0}^{x_0+h}f(x)dx=\frac{h}{2}\left(f(x_0+h) + f(x_0)\right)+O(h^3).
\end{equation*}
$$

Here we added the error made in approximating our integral 
with a polynomial of degree \( 1 \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec8">The trapezoidal rule </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The other integral gives
$$
\begin{equation*}
\int_{x_0-h}^{x_0}f(x)dx=\frac{h}{2}\left(f(x_0) + f(x_0-h)\right)+O(h^3),
\end{equation*}
$$

and adding up we obtain
$$
\begin{equation}
   \int_{x_0-h}^{x_0+h}f(x)dx=\frac{h}{2}\left(f(x_0+h) + 2f(x_0) + f(x_0-h)\right)+O(h^3),
\label{eq:trapez}
\end{equation}
$$

which is the well-known trapezoidal rule.  Concerning the error in the approximation made,
\( O(h^3)=O((b-a)^3/N^3) \), you should  note 
that this is the local error.  Since we are splitting the integral from
\( a \) to \( b \) in \( N \) pieces, we will have to perform approximately \( N \) 
such operations.
</div>


<p>
<!-- !split  -->

<h2 id="___sec9">Global error </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
This means that the <em>global error</em> goes like \( \approx O(h^2) \). 
The trapezoidal reads then
$$
\begin{equation}
   I=\int_a^bf(x) dx=h\left(f(a)/2 + f(a+h) +f(a+2h)+
                          \dots +f(b-h)+ f_{b}/2\right),
\label{eq:trapez1}
\end{equation}
$$

with a global error which goes like \( O(h^2) \).

<p>
Hereafter we use the shorthand notations \( f_{-h}=f(x_0-h) \), \( f_{0}=f(x_0) \)
and \( f_{h}=f(x_0+h) \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec10">Error in the trapezoidal rule </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The correct mathematical expression for the local error for the trapezoidal rule is
$$
\begin{equation*}
\int_a^bf(x)dx -\frac{b-a}{2}\left[f(a)+f(b)\right]=-\frac{h^3}{12}f^{(2)}(\xi),
\end{equation*}
$$

and the global error reads
$$
\begin{equation*}
\int_a^bf(x)dx -T_h(f)=-\frac{b-a}{12}h^2f^{(2)}(\xi),
\end{equation*}
$$

where \( T_h \) is the trapezoidal result and \( \xi \in [a,b] \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec11">Algorithm for the trapezoidal rule </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The trapezoidal rule is easy to  implement numerically 
through the following simple algorithm

<ul>
  <li> Choose the number of mesh points and fix the step length.</li>
  <li> calculate \( f(a) \) and \( f(b) \) and multiply with \( h/2 \).</li>
  <li> Perform a loop over \( n=1 \) to \( n-1 \) (\( f(a) \) and \( f(b) \) are known) and sum up  the terms \( f(a+h) +f(a+2h)+f(a+3h)+\dots +f(b-h) \). Each step in the loop  corresponds to a given value \( a+nh \).</li>
  <li> Multiply the final result by \( h \) and add \( hf(a)/2 \) and \( hf(b)/2 \).</li>
</ul>
</div>


<p>
<!-- !split  -->

<h2 id="___sec12">Code example  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A simple function which implements this algorithm is as follows
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #B00040">double</span> <span style="color: #0000FF">TrapezoidalRule</span>(<span style="color: #B00040">double</span> a, <span style="color: #B00040">double</span> b, <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> (<span style="color: #666666">*</span>func)(<span style="color: #B00040">double</span>))
{
      <span style="color: #B00040">double</span> TrapezSum;
      <span style="color: #B00040">double</span> fa, fb, x, step;
      <span style="color: #B00040">int</span>    j;
      step<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>((<span style="color: #B00040">double</span>) n);
      fa<span style="color: #666666">=</span>(<span style="color: #666666">*</span>func)(a)<span style="color: #666666">/2.</span> ;
      fb<span style="color: #666666">=</span>(<span style="color: #666666">*</span>func)(b)<span style="color: #666666">/2.</span> ;
      TrapezSum<span style="color: #666666">=0.</span>;
      <span style="color: #008000; font-weight: bold">for</span> (j<span style="color: #666666">=1</span>; j <span style="color: #666666">&lt;=</span> n<span style="color: #666666">-1</span>; j<span style="color: #666666">++</span>){
         x<span style="color: #666666">=</span>j<span style="color: #666666">*</span>step<span style="color: #666666">+</span>a;
         TrapezSum<span style="color: #666666">+=</span>(<span style="color: #666666">*</span>func)(x);
      }
      TrapezSum<span style="color: #666666">=</span>(TrapezSum<span style="color: #666666">+</span>fb<span style="color: #666666">+</span>fa)<span style="color: #666666">*</span>step;
      <span style="color: #008000; font-weight: bold">return</span> TrapezSum;
}  <span style="color: #408080; font-style: italic">// end TrapezoidalRule </span>
</pre></div>
<p>
The function returns a new value for the specific integral through the variable <b>TrapezSum</b>.
</div>


<p>
<!-- !split  -->

<h2 id="___sec13">Transfer of  function names  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
There is one new feature to note here, namely
the transfer of a user defined function called <b>func</b> in the 
definition 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #B00040">void</span> TrapezoidalRule(<span style="color: #B00040">double</span> a, <span style="color: #B00040">double</span> b, <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>TrapezSum, <span style="color: #B00040">double</span> (<span style="color: #666666">*</span>func)(<span style="color: #B00040">double</span>) )  
</pre></div>
<p>
What happens here is that we are transferring a pointer to the name 
of a user defined function, which has as input a double precision variable and returns
a double precision number. The function  <b>TrapezoidalRule</b> is called as
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  TrapezoidalRule(a, b, n, <span style="color: #666666">&amp;</span>MyFunction )       
</pre></div>
<p>
in the calling function. We note that <b>a</b>, <b>b</b> and <b>n</b> are called by value,
while <b>TrapezSum</b> and the user defined function <b>MyFunction</b>
are called by reference.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Going back to Python, why?  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Symbolic calculations and numerical calculations in one code!</b>
<p>
Python offers an  extremely versatile programming  environment, allowing for 
the inclusion of analytical studies in a numerical program. Here we show an
example code with the <b>trapezoidal rule</b> using <b>SymPy</b> to evaluate an integral and compute the absolute error
with respect to the numerically evaluated one of the integral
\( 4\int_0^1 dx/(1+x^2) = \pi \):
<p>


<div class="compute"><script type="text/x-sage">
from math import *
from sympy import *
def Trapez(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s

#  function to compute pi
def function(x):
    return 4.0/(1+x*x)

a = 0.0;  b = 1.0; n = 100
result = Trapez(a,b,function,n)
print "Trapezoidal rule=", result
# define x as a symbol to be used by sympy
x = Symbol('x')
exact = integrate(function(x), (x, 0.0, 1.0))
print "Sympy integration=", exact
# Find relative error
print "Relative error", abs((exact-result)/exact)

</script></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec15">Error analysis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The following extended version of the trapezoidal rule allows you  to plot the relative error by comparing with the exact result. By increasing to \( 10^8 \) points one arrives at a region where numerical errors start to accumulate.
<p>


<div class="compute"><script type="text/x-sage">
from math import log10
import numpy as np
from sympy import Symbol, integrate
import matplotlib.pyplot as plt
# function for the trapezoidal rule
def Trapez(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s
#  function to compute pi
def function(x):
    return 4.0/(1+x*x)
# define integration limits
a = 0.0;  b = 1.0;
# find result from sympy
# define x as a symbol to be used by sympy
x = Symbol('x')
exact = integrate(function(x), (x, a, b))
# set up the arrays for plotting the relative error
n = np.zeros(9); y = np.zeros(9);
# find the relative error as function of integration points
for i in range(1, 8, 1):
    npts = 10**i
    result = Trapez(a,b,function,npts)
    RelativeError = abs((exact-result)/exact)
    n[i] = log10(npts); y[i] = log10(RelativeError);
plt.plot(n,y, 'ro')
plt.xlabel('n')
plt.ylabel('Relative error')
plt.show()

</script></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec16">Integrating numerical mathematics with calculus </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The last example shows the potential of combining numerical algorithms with 
symbolic calculations, allowing us thereby to

<ul>
<li> Validate and verify  our  algorithms.</li>
<li> Including concepts like unit testing, one has the possibility to test and  validate several or all parts of the code.</li>
<li> Validation and verification are then included <em>naturally</em>.</li>
<li> The above example allows you to test the mathematical error of the algorithm for the trapezoidal rule by changing the number of integration points. You get trained from day one to think error analysis.</li>
</ul>
</div>


<p>
<!-- !split  -->

<h2 id="___sec17">The rectangle method </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Another very simple approach is the so-called midpoint or rectangle method.
In this case the integration area is split in a given number of rectangles with length \( h \) and height given by the mid-point value of the function.  This gives the following simple rule for approximating an integral
$$
\begin{equation}
   I=\int_a^bf(x) dx \approx  h\sum_{i=1}^N f(x_{i-1/2}), 
\label{eq:rectangle}
\end{equation}
$$

where \( f(x_{i-1/2}) \) is the midpoint value of \( f \) for a given rectangle. We will discuss its truncation 
error below.  It is easy to implement this algorithm,  as shown here
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #B00040">double</span> <span style="color: #0000FF">RectangleRule</span>(<span style="color: #B00040">double</span> a, <span style="color: #B00040">double</span> b, <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> (<span style="color: #666666">*</span>func)(<span style="color: #B00040">double</span>))
{
      <span style="color: #B00040">double</span> RectangleSum;
      <span style="color: #B00040">double</span> fa, fb, x, step;
      <span style="color: #B00040">int</span>    j;
      step<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>((<span style="color: #B00040">double</span>) n);
      RectangleSum<span style="color: #666666">=0.</span>;
      <span style="color: #008000; font-weight: bold">for</span> (j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;=</span> n; j<span style="color: #666666">++</span>){
         x <span style="color: #666666">=</span> (j<span style="color: #666666">+0.5</span>)<span style="color: #666666">*</span>step<span style="color: #666666">+</span>;   <span style="color: #408080; font-style: italic">// midpoint of a given rectangle</span>
         RectangleSum<span style="color: #666666">+=</span>(<span style="color: #666666">*</span>func)(x);   <span style="color: #408080; font-style: italic">//  add value of function.</span>
      }
      RectangleSum <span style="color: #666666">*=</span> step;  <span style="color: #408080; font-style: italic">//  multiply with step length.</span>
      <span style="color: #008000; font-weight: bold">return</span> RectangleSum;
}  <span style="color: #408080; font-style: italic">// end RectangleRule </span>
</pre></div>

</div>


<p>
<!-- !split  -->

<h2 id="___sec18">Truncation error for the rectangular rule  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The correct mathematical expression for the local error for the rectangular rule \( R_i(h) \) for element \( i \) is

$$
\begin{equation*}
\int_{-h}^hf(x)dx - R_i(h)=-\frac{h^3}{24}f^{(2)}(\xi),
\end{equation*}
$$

and the global error reads
$$
\begin{equation*}
\int_a^bf(x)dx -R_h(f)=-\frac{b-a}{24}h^2f^{(2)}(\xi),
\end{equation*}
$$

where \( R_h \) is the result obtained with rectangular rule and \( \xi \in [a,b] \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec19">Second-order polynomial </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Instead of using the above first-order polynomials 
approximations for \( f \), we attempt at using a second-order polynomials.
In this case we need three points in order to define a second-order 
polynomial approximation
$$
\begin{equation*}
f(x) \approx P_2(x)=a_0+a_1x+a_2x^2.
\end{equation*}
$$

Using again Lagrange's interpolation formula we have
$$
\begin{equation*}
     P_2(x)=\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}y_2+
            \frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}y_1+
            \frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}y_0.
\end{equation*}
$$

Inserting this formula in the integral of Eq.  \eqref{eq:hhint} we obtain
$$
\begin{equation*}
   \int_{-h}^{+h}f(x)dx=\frac{h}{3}\left(f_h + 4f_0 + f_{-h}\right)+O(h^5),
\end{equation*}
$$

which is Simpson's rule.
</div>


<p>
<!-- !split  -->

<h2 id="___sec20">Simpson's rule </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Note that the improved accuracy in the evaluation of
the derivatives gives a better error approximation, \( O(h^5) \) vs.\ \( O(h^3) \) .
But this is again the <em>local error approximation</em>. 
Using Simpson's rule we can easily compute
the integral     of Eq.  \eqref{eq:integraldef} to be
$$
\begin{equation}
   I=\int_a^bf(x) dx=\frac{h}{3}\left(f(a) + 4f(a+h) +2f(a+2h)+
                          \dots +4f(b-h)+ f_{b}\right),
\label{eq:simpson}
\end{equation}
$$

with a global error which goes like \( O(h^4) \).
</div>


<p>
<!-- !split  -->

<h2 id="___sec21">Mathematical expressions for the truncation error </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
More formal expressions for the local and global errors are for the local error
$$
\begin{equation*}
\int_a^bf(x)dx -\frac{b-a}{6}\left[f(a)+4f((a+b)/2)+f(b)\right]=-\frac{h^5}{90}f^{(4)}(\xi),
\end{equation*}
$$

and for the global error
$$
\begin{equation*}
\int_a^bf(x)dx -S_h(f)=-\frac{b-a}{180}h^4f^{(4)}(\xi).
\end{equation*}
$$

with \( \xi\in[a,b] \) and \( S_h \) the results obtained with Simpson's method.
</div>


<p>
<!-- !split  -->

<h2 id="___sec22">Algorithm for Simpson's rule </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The method 
can easily be implemented numerically through the following simple algorithm

<ul>
  <li> Choose the number of mesh points and fix the step.</li>
  <li> calculate \( f(a) \) and \( f(b) \)</li>
  <li> Perform a loop over \( n=1 \) to \( n-1 \) (\( f(a) \) and \( f(b) \) are known) and sum up   the terms \( 4f(a+h) +2f(a+2h)+4f(a+3h)+\dots +4f(b-h) \). Each step in the loop  corresponds to a given value \( a+nh \). Odd values of \( n \) give \( 4 \) as factor  while even values yield \( 2 \) as factor.</li>
  <li> Multiply the final result by \( \frac{h}{3} \).</li>
</ul>
</div>


<p>
<!-- !split  -->

<h2 id="___sec23">Summary for equal-step methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In more general terms, what we have done here is to approximate a given function \( f(x) \) with a polynomial
of a certain degree. One can show that 
given \( n+1 \) distinct points \( x_0,\dots, x_n\in[a,b] \) and \( n+1 \) values \( y_0,\dots,y_n \) there exists a 
unique polynomial \( P_n(x) \) with the property
$$
\begin{equation*}
   P_n(x_j) = y_j\hspace{0.5cm} j=0,\dots,n
\end{equation*}
$$
</div>


<p>
<!-- !split  -->

<h2 id="___sec24">Lagrange's polynomial </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In the Lagrange representation the interpolating polynomial is given by
$$
\begin{equation*}
P_n = \sum_{k=0}^nl_ky_k,
\end{equation*}
$$

with the Lagrange factors
$$
\begin{equation*}
   l_k(x) = \prod_{\begin{array}{c}i=0 \\ i\ne k\end{array}}^n\frac{x-x_i}{x_k-x_i}\hspace{0.2cm} k=0,\dots,n.
\end{equation*}
$$
</div>


<p>
<!-- !split  -->

<h2 id="___sec25">Polynomial approximation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we for example set \( n=1 \), we obtain
$$
\begin{equation*}
P_1(x) = y_0\frac{x-x_1}{x_0-x_1}+y_1\frac{x-x_0}{x_1-x_0}=\frac{y_1-y_0}{x_1-x_0}x-\frac{y_1x_0+y_0x_1}{x_1-x_0},
\end{equation*}
$$

which we recognize as the equation for a straight line.

<p>
The polynomial interpolatory quadrature of order \( n \) with equidistant quadrature points \( x_k=a+kh \)
and step \( h=(b-a)/n \) is called the Newton-Cotes quadrature formula of order \( n \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec26">Gaussian Quadrature </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The methods we have presented hitherto are tailored to problems where the 
mesh points \( x_i \) are equidistantly spaced, \( x_i \) differing from \( x_{i+1} \) by the step \( h \).

<p>
The basic idea behind all integration methods is to approximate the integral
$$
\begin{equation*} 
   I=\int_a^bf(x)dx \approx \sum_{i=1}^N\omega_if(x_i),  
\end{equation*}
$$

where \( \omega \) and \( x \) are the weights and the chosen mesh points, respectively.
In our previous discussion, these mesh points were fixed at the beginning, by choosing
a given number of points \( N \). The weigths \( \omega \) resulted then from the integration
method we applied. Simpson's rule, see Eq.  \eqref{eq:simpson} would give
$$
\begin{equation*}
   \omega : \left\{h/3,4h/3,2h/3,4h/3,\dots,4h/3,h/3\right\},
\end{equation*}
$$

for the weights, while the trapezoidal rule resulted in
$$
\begin{equation*}
   \omega : \left\{h/2,h,h,\dots,h,h/2\right\}.
\end{equation*}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Gaussian Quadrature, main idea </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In general, an integration formula which is based on a Taylor series using \( N \) points,
will integrate exactly a polynomial \( P \) of degree \( N-1 \). That is, the \( N \) weights
\( \omega_n \) can be chosen to satisfy \( N \) linear equations, see chapter 3 of Ref.\ [3]. 
A greater precision for a given amount of numerical work can  be achieved
if we are willing to give up the requirement of equally spaced integration points.  
In Gaussian quadrature (hereafter GQ), both the mesh points and the weights are to
be determined. The points will not be equally spaced.

<p>
The theory behind GQ is to obtain an arbitrary weight \( \omega \) through the use of
so-called orthogonal polynomials. These polynomials are orthogonal in some
interval say e.g., [-1,1]. Our points \( x_i \) are chosen in some optimal sense subject
only to the constraint that they should lie in this interval. Together with the weights
we have then \( 2N \) (\( N \) the number of points) parameters at our disposal.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Gaussian Quadrature </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Even though the integrand is not smooth, we could render it smooth by extracting
from it the weight function of an orthogonal polynomial, i.e.,
we are rewriting
$$
\begin{equation}
   I= \int_a^b f(x)dx =\int_a^b W(x)g(x)dx \approx \sum_{i=1}^N\omega_ig(x_i),  
\label{eq:generalint}
\end{equation}
$$

where \( g \) is smooth and \( W \) is the weight function, which is to  be associated with a given 
orthogonal polynomial. Note that with a given weight function we end up evaluating the integrand
for the function \( g(x_i) \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec29">Gaussian Quadrature, weight function </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The weight function \( W \) is non-negative in the integration interval 
\( x\in [a,b] \) such that
for any \( n \ge 0 \), the integral \( \int_a^b |x|^n W(x) dx \) is integrable. The naming
weight function arises from the fact that it may be used to give more emphasis
to one part of the interval than another. 
A quadrature formula 
$$
\begin{equation} 
   \int_a^b W(x)f(x)dx \approx \sum_{i=1}^N\omega_if(x_i), 
\label{_auto1}
\end{equation} 
$$

with \( N \) distinct quadrature points (mesh points) is a called a Gaussian quadrature 
formula if it integrates all polynomials \( p\in P_{2N-1} \) exactly, that is
$$
\begin{equation} 
\int_a^bW(x)p(x)dx =\sum_{i=1}^N\omega_ip(x_i), 
\label{_auto2}
\end{equation}
$$

It is assumed that \( W(x) \) is continuous and positive and that the integral
$$
\begin{equation*} 
\int_a^bW(x)dx
\end{equation*}
$$

exists. Note that the replacement of \( f\rightarrow Wg \) is normally a better approximation
due to the fact that we may isolate possible singularities of \( W \) and its 
derivatives at the endpoints of the interval.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec30">Gaussian Quadrature weights and integration points </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The quadrature weights or just weights (not to be confused with the weight function) 
are positive and the sequence of Gaussian quadrature formulae is convergent 
if the sequence \( Q_N \) of quadrature formulae
$$
\begin{equation*}
   Q_N(f)\rightarrow Q(f)=\int_a^bf(x)dx,
\end{equation*}
$$

in the limit \( N\rightarrow \infty \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec31">Gaussian Quadrature </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Then  we say that the sequence
$$
\begin{equation*} 
Q_N(f) = \sum_{i=1}^N\omega_i^{(N)}f(x_i^{(N)}), 
\end{equation*}
$$

is convergent for all polynomials \( p \), that is
$$
\begin{equation*}
Q_N(p) = Q(p) 
\end{equation*}
$$

if there exits a constant \( C \) such that
$$
\begin{equation*}
 \sum_{i=1}^N|\omega_i^{(N)}| \le C,
\end{equation*}
$$

for all \( N \) which are natural numbers.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec32">Error in Gaussian Quadrature </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The error for the Gaussian quadrature formulae of order \( N \) is given
by

$$
\begin{equation*}
  \int_a^bW(x)f(x)dx-\sum_{k=1}^Nw_kf(x_k)=\frac{f^{2N}(\xi)}{(2N)!}\int_a^bW(x)[q_{N}(x)]^2dx
\end{equation*}
$$

where \( q_{N} \) is the chosen orthogonal polynomial and \( \xi \) is a number in the interval \( [a,b] \).
We have assumed that \( f\in C^{2N}[a,b] \), viz. the space of all real or complex  \( 2N \) times continuously
differentiable functions.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec33">Important polynomials in Gaussian Quadrature </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In science there are several important orthogonal polynomials which arise
from the solution of differential equations. Well-known examples are the  
Legendre, Hermite, Laguerre and Chebyshev polynomials. They have the following weight functions

<p>
<table border="1">
<thead>
<tr><th align="center">      Weight function      </th> <th align="center">           Interval           </th> <th align="center">Polynomial</th> </tr>
</thead>
<tbody>
<tr><td align="right">   \( W(x)=1 \)                   </td> <td align="right">   \( x\in [-1,1] \)                 </td> <td align="right">   Legendre      </td> </tr>
<tr><td align="right">   \( W(x)=e^{-x^2} \)            </td> <td align="right">   \( -\infty \le x \le \infty \)    </td> <td align="right">   Hermite       </td> </tr>
<tr><td align="right">   \( W(x)=x^{\alpha}e^{-x} \)    </td> <td align="right">   \( 0 \le x \le \infty \)          </td> <td align="right">   Laguerre      </td> </tr>
<tr><td align="right">   \( W(x)=1/(\sqrt{1-x^2}) \)    </td> <td align="right">   \( -1 \le x \le 1 \)              </td> <td align="right">   Chebyshev     </td> </tr>
</tbody>
</table>
<p>
The importance of the use of orthogonal polynomials in the evaluation
of integrals can be summarized as follows.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec34">Gaussian Quadrature, win-win situation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Methods based on Taylor series using \( N \) points will  integrate exactly a polynomial \( P \) of degree \( N-1 \). If a function \( f(x) \) can be approximated with a polynomial of degree \( N-1 \)          
$$
\begin{equation*}            
f(x)\approx P_{N-1}(x),
\end{equation*}
$$

with \( N \) mesh points we should be able to integrate exactly the polynomial \( P_{N-1} \).

<p>
Gaussian quadrature methods promise more than this. We can get a better          polynomial approximation with order greater than \( N \)  to \( f(x) \) and still          get away with only \( N \) mesh points. More precisely, we approximate           
$$
\begin{equation*}             
f(x) \approx P_{2N-1}(x),
\end{equation*}
$$

and with only \( N \) mesh points these methods promise that
$$
\begin{equation*}
            \int f(x)dx \approx \int P_{2N-1}(x)dx=\sum_{i=0}^{N-1} P_{2N-1}(x_i)\omega_i,
\end{equation*}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec35">Gaussian Quadrature, determining mesh points and weights </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
The reason why we can represent a function \( f(x) \) with a polynomial of degree
\( 2N-1 \) is due to the fact that we have \( 2N \) equations, \( N \) for the mesh points and \( N \)
for the weights.

<p>
<em>The mesh points are the zeros  of the chosen  orthogonal polynomial</em> of
order \( N \), and the weights are determined from the inverse of a matrix.
An orthogonal polynomials of degree \( N \) defined in an interval \( [a,b] \)
has precisely \( N \) distinct zeros on the open interval \( (a,b) \).

<p>
Before we detail how to obtain mesh points and weights with orthogonal 
polynomials, let us revisit some features of orthogonal polynomials
by specializing to Legendre polynomials. In the text below, we reserve 
hereafter the labelling
\( L_N \) for a Legendre polynomial of order \( N \), while \( P_N \) is an arbitrary polynomial
of order \( N \). 
These polynomials form then the basis for the Gauss-Legendre method.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec36">Orthogonal polynomials, Legendre </h2>

<p>
The Legendre polynomials are the solutions of an important
differential equation in Science, namely

$$
\begin{equation*}
C(1-x^2)P-m_l^2P+(1-x^2)\frac{d}{dx}\left((1-x^2)\frac{dP}{dx}\right)=0.
\end{equation*}
$$

Here \( C \) is a constant. For \( m_l=0 \) we obtain the Legendre polynomials
as solutions, whereas \( m_l \ne 0 \) yields the so-called associated Legendre
polynomials. This differential equation arises in for example the solution
of the angular dependence of Schroedinger's 
equation with spherically symmetric potentials such as
the Coulomb potential.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec37">Orthogonal polynomials, Legendre </h2>
The corresponding polynomials \( P \) are
$$
\begin{equation*}
   L_k(x)=\frac{1}{2^kk!}\frac{d^k}{dx^k}(x^2-1)^k \hspace{1cm} k=0,1,2,\dots,
\end{equation*}
$$

which, up to a factor, are the Legendre polynomials \( L_k \). 
The latter fulfil the orthogonality relation
$$
\begin{equation} 
  \int_{-1}^1L_i(x)L_j(x)dx=\frac{2}{2i+1}\delta_{ij},
\label{eq:ortholeg}
\end{equation} 
$$

and the recursion relation
$$
\begin{equation} 
  (j+1)L_{j+1}(x)+jL_{j-1}(x)-(2j+1)xL_j(x)=0.
\label{eq:legrecur}
\end{equation} 
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec38">Orthogonal polynomials, Legendre </h2>
It is common to choose the normalization condition
$$
\begin{equation*}
    L_N(1)=1.
\end{equation*}
$$

With these equations we can determine a Legendre polynomial of arbitrary order
with input polynomials of order \( N-1 \) and \( N-2 \).

<p>
As an example, consider the determination of \( L_0 \), \( L_1 \) and \( L_2 \). 
We have that
$$
\begin{equation*}
   L_0(x) = c,
\end{equation*}
$$

with \( c \) a constant. Using the normalization equation \( L_0(1)=1 \)
we get that

$$
\begin{equation*}
   L_0(x) = 1.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec39">Orthogonal polynomials, Legendre </h2>
For \( L_1(x) \) we have the general expression
$$
\begin{equation*}
   L_1(x) = a+bx,
\end{equation*}
$$

and using the orthogonality relation
$$
\begin{equation*}
  \int_{-1}^1L_0(x)L_1(x)dx=0,
\end{equation*}
$$

we obtain \( a=0 \) and with the condition \( L_1(1)=1 \), we obtain \( b=1 \), yielding
$$
\begin{equation*}
   L_1(x) = x.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec40">Orthogonal polynomials, Legendre </h2>
We can proceed in a similar fashion in order to determine
the coefficients of \( L_2 \)
$$
\begin{equation*}
   L_2(x) = a+bx+cx^2,
\end{equation*}
$$

using the orthogonality relations
$$
\begin{equation*}
  \int_{-1}^1L_0(x)L_2(x)dx=0,
\end{equation*}
$$

and
$$
\begin{equation*}
  \int_{-1}^1L_1(x)L_2(x)dx=0,
\end{equation*}
$$

and the condition
\( L_2(1)=1 \) we would get 
$$
\begin{equation}
   L_2(x) = \frac{1}{2}\left(3x^2-1\right).
\label{eq:l2}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec41">Orthogonal polynomials, Legendre </h2>
We note that we have three equations to determine the three coefficients
\( a \), \( b \) and \( c \).

<p>
Alternatively, we could have 
employed the recursion relation of Eq. \eqref{eq:legrecur}, resulting in

$$
\begin{equation*}
   2L_2(x)=3xL_1(x)-L_0,
\end{equation*}
$$

which leads to Eq. \eqref{eq:l2}.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec42">Orthogonal polynomials, Legendre </h2>
The orthogonality relation above is important in our discussion
on how to obtain the weights and mesh points. Suppose we have an arbitrary
polynomial \( Q_{N-1} \) of order \( N-1 \) and a Legendre polynomial \( L_N(x) \) of
order \( N \). We could represent \( Q_{N-1} \) 
by the Legendre polynomials through 
$$
\begin{equation}
   Q_{N-1}(x)=\sum_{k=0}^{N-1}\alpha_kL_{k}(x),
\label{eq:legexpansion}
\end{equation}
$$

where \( \alpha_k \)'s are constants.

<p>
Using the orthogonality relation of Eq. \eqref{eq:ortholeg} we see that
$$
\begin{equation}
  \int_{-1}^1L_N(x)Q_{N-1}(x)dx=\sum_{k=0}^{N-1} \int_{-1}^1L_N(x) \alpha_kL_{k}(x)dx=0.
\label{eq:ortholeg2}
\end{equation}
$$

We will use this result in our construction of mesh points and weights 
in the next subsection.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec43">Orthogonal polynomials, Legendre </h2>
In summary, the first few Legendre polynomials are
$$
\begin{equation*}
   L_0(x) =1,
\end{equation*}
$$

$$
\begin{equation*}
  L_1(x) = x,
\end{equation*}
$$

$$
\begin{equation*}
  L_2(x) = (3x^2-1)/2,
\end{equation*}
$$

$$
\begin{equation*}
   L_3(x) = (5x^3-3x)/2,
\end{equation*}
$$

and
$$
\begin{equation*}
   L_4(x) = (35x^4-30x^2+3)/8.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec44">Orthogonal polynomials, simple code for Legendre polynomials </h2>
The following simple function implements the above recursion relation
of Eq. \eqref{eq:legrecur}.
for computing Legendre polynomials of order \( N \).
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic">//  This function computes the Legendre polynomial of degree N</span>

<span style="color: #B00040">double</span> <span style="color: #0000FF">Legendre</span>( <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> x) 
{
       <span style="color: #B00040">double</span> r, s, t;
       <span style="color: #B00040">int</span> m;
       r <span style="color: #666666">=</span> <span style="color: #666666">0</span>; s <span style="color: #666666">=</span> <span style="color: #666666">1.</span>;
       <span style="color: #408080; font-style: italic">//  Use recursion relation to generate p1 and p2</span>
       <span style="color: #008000; font-weight: bold">for</span> (m<span style="color: #666666">=0</span>; m <span style="color: #666666">&lt;</span> n; m<span style="color: #666666">++</span> )  
       {
          t <span style="color: #666666">=</span> r; r <span style="color: #666666">=</span> s; 
          s <span style="color: #666666">=</span> (<span style="color: #666666">2*</span>m<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x<span style="color: #666666">*</span>r <span style="color: #666666">-</span> m<span style="color: #666666">*</span>t;
          s <span style="color: #666666">/=</span> (m<span style="color: #666666">+1</span>);
	} <span style="color: #408080; font-style: italic">// end of do loop </span>
        <span style="color: #008000; font-weight: bold">return</span> s;
}   <span style="color: #408080; font-style: italic">// end of function Legendre</span>
</pre></div>
<p>
The variable \( s \) represents \( L_{j+1}(x) \), while \( r \) holds
\( L_j(x) \) and \( t \) the value \( L_{j-1}(x) \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec45">Integration points and weights with orthogonal polynomials </h2>

<p>
To understand how the weights and the mesh points are generated, we define first
a polynomial of degree \( 2N-1 \) (since we have \( 2N \) variables at hand, the mesh points
and weights for \( N \) points). This polynomial can be represented through polynomial
division by

$$
\begin{equation*}
   P_{2N-1}(x)=L_N(x)P_{N-1}(x)+Q_{N-1}(x),
\end{equation*}
$$

where \( P_{N-1}(x) \) and \( Q_{N-1}(x) \) are some polynomials of degree \( N-1 \) or less.
The function \( L_N(x) \) is a Legendre polynomial of order \( N \).

<p>
Recall that we wanted to approximate  an arbitrary function \( f(x) \) with a
polynomial \( P_{2N-1} \) in order to evaluate

$$
\begin{equation*}
   \int_{-1}^1f(x)dx\approx \int_{-1}^1P_{2N-1}(x)dx.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec46">Integration points and weights with orthogonal polynomials </h2>
We can use Eq. \eqref{eq:ortholeg2}
to rewrite the above integral as
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1(L_N(x)P_{N-1}(x)+Q_{N-1}(x))dx=\int_{-1}^1Q_{N-1}(x)dx,
\end{equation*}
$$

due to the orthogonality properties of the Legendre polynomials. We see that it suffices
to evaluate the integral over \( \int_{-1}^1Q_{N-1}(x)dx \) in order to evaluate 
\( \int_{-1}^1P_{2N-1}(x)dx \). In addition, at the points \( x_k \) where \( L_N \) is zero, we have

$$
\begin{equation*}
    P_{2N-1}(x_k)=Q_{N-1}(x_k)\hspace{1cm} k=0,1,\dots, N-1,
\end{equation*}
$$

and we see that through these \( N \) points we can fully define \( Q_{N-1}(x) \)  and thereby the 
integral. Note that we have chosen to let the numbering of the points run from \( 0 \) to \( N-1 \).
The reason for this choice is that we wish to have the same numbering as the order of a 
polynomial of degree \( N-1 \).  This numbering will be useful below when  we introduce the matrix
elements  which define the integration weights \( w_i \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec47">Integration points and weights with orthogonal polynomials </h2>
We develope then \( Q_{N-1}(x) \) in terms of Legendre polynomials,
as done in Eq. \eqref{eq:legexpansion}, 
$$
\begin{equation} 
  Q_{N-1}(x)=\sum_{i=0}^{N-1}\alpha_iL_i(x).
\label{eq:lsum1}
\end{equation}
$$

Using the orthogonality property of the Legendre polynomials we have
$$
\begin{equation*} 
  \int_{-1}^1Q_{N-1}(x)dx=\sum_{i=0}^{N-1}\alpha_i\int_{-1}^1L_0(x)L_i(x)dx=2\alpha_0,
\end{equation*}
$$

where we have just inserted \( L_0(x)=1 \)!

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec48">Integration points and weights with orthogonal polynomials </h2>
Instead of an integration problem we need now to define the coefficient \( \alpha_0 \).
Since we know the values of \( Q_{N-1} \) at the zeros of \( L_N \), we may rewrite  
Eq.  \eqref{eq:lsum1} as
$$
\begin{equation} 
  Q_{N-1}(x_k)=\sum_{i=0}^{N-1}\alpha_iL_i(x_k)=\sum_{i=0}^{N-1}\alpha_iL_{ik} \hspace{1cm} k=0,1,\dots, N-1.
\label{eq:lsum2}
\end{equation}
$$

Since the Legendre polynomials are linearly independent of each other, none 
of the columns in the matrix \( L_{ik} \) are linear combinations of the others.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec49">Integration points and weights with orthogonal polynomials </h2>
This means that the matrix \( L_{ik} \) has an inverse with the properties
$$
\begin{equation*}
   \hat{L}^{-1}\hat{L} = \hat{I}.
\end{equation*}
$$

Multiplying both sides of Eq. \eqref{eq:lsum2} with \( \sum_{j=0}^{N-1}L_{ji}^{-1} \) results in 
$$
\begin{equation}
  \sum_{i=0}^{N-1}(L^{-1})_{ki}Q_{N-1}(x_i)=\alpha_k.
\label{eq:lsum3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec50">Integration points and weights with orthogonal polynomials </h2>
We can derive this result in an alternative way by defining the vectors
$$
\begin{equation*}
\hat{x}_k=\left(\begin{array} {c} x_0\\
                                x_1\\
                                .\\
                                .\\
                                x_{N-1}\end{array}\right) \hspace{0.5cm}
\hat{\alpha}=\left(\begin{array} {c} \alpha_0\\
                                \alpha_1\\
                                .\\
                                .\\
                                \alpha_{N-1}\end{array}\right),
\end{equation*}
$$

and the matrix
$$
\begin{equation*}
   \hat{L}=\left(\begin{array} {cccc} L_0(x_0)  & L_1(x_0) &\dots &L_{N-1}(x_0)\\
                                   L_0(x_1)  & L_1(x_1) &\dots &L_{N-1}(x_1)\\
                                   \dots  & \dots &\dots &\dots\\
L_0(x_{N-1})  & L_1(x_{N-1}) &\dots &L_{N-1}(x_{N-1})
\end{array}\right).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec51">Integration points and weights with orthogonal polynomials </h2>
We have then
$$
\begin{equation*}
Q_{N-1}(\hat{x}_k) = \hat{L}\hat{\alpha},
\end{equation*}
$$

yielding (if \( \hat{L} \) has an inverse)
$$
\begin{equation*}
\hat{L}^{-1}Q_{N-1}(\hat{x}_k) = \hat{\alpha},
\end{equation*}
$$

which is Eq. \eqref{eq:lsum3}.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec52">Integration points and weights with orthogonal polynomials </h2>
Using the above results and the fact that
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1Q_{N-1}(x)dx,
\end{equation*}
$$

we get
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1Q_{N-1}(x)dx=2\alpha_0=
   2\sum_{i=0}^{N-1}(L^{-1})_{0i}P_{2N-1}(x_i).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec53">Integration points and weights with orthogonal polynomials </h2>
If we identify the weights with \( 2(L^{-1})_{0i} \), where the points \( x_i \) are
the zeros of \( L_N \), we have an integration formula of the type
$$
\begin{equation*}
   \int_{-1}^1P_{2N-1}(x)dx=\sum_{i=0}^{N-1}\omega_iP_{2N-1}(x_i)  
\end{equation*}
$$

and if our function \( f(x) \)  can be approximated by a polynomial \( P \) of degree
\( 2N-1 \), we have finally that
$$
\begin{equation*}
    \int_{-1}^1f(x)dx\approx \int_{-1}^1P_{2N-1}(x)dx=\sum_{i=0}^{N-1}\omega_iP_{2N-1}(x_i)  .
\end{equation*}
$$

In summary, the mesh points \( x_i \) are defined by the zeros of an orthogonal polynomial of degree \( N \), that is 
\( L_N \), while the weights are
given by \( 2(L^{-1})_{0i} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec54">Application to the case \( N=2 \) </h2>

<p>
Let us apply the above formal results to the case \( N=2 \). 
This means that we can approximate a function \( f(x) \) with a
polynomial \( P_3(x) \) of order \( 2N-1=3 \).

<p>
The mesh points are the zeros of \( L_2(x)=1/2(3x^2-1) \). 
These points are \( x_0=-1/\sqrt{3} \) and \( x_1=1/\sqrt{3} \).

<p>
Specializing Eq. \eqref{eq:lsum2}

$$
\begin{equation*} 
  Q_{N-1}(x_k)=\sum_{i=0}^{N-1}\alpha_iL_i(x_k) \hspace{1cm} k=0,1,\dots, N-1.
\end{equation*}
$$

to \( N=2 \) yields

$$
\begin{equation*}
   Q_1(x_0)=\alpha_0-\alpha_1\frac{1}{\sqrt{3}},
\end{equation*}
$$

and

$$
\begin{equation*}
   Q_1(x_1)=\alpha_0+\alpha_1\frac{1}{\sqrt{3}},
\end{equation*}
$$

since \( L_0(x=\pm 1/\sqrt{3})=1 \) and \( L_1(x=\pm 1/\sqrt{3})=\pm 1/\sqrt{3} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec55">Application to the case \( N=2 \) </h2>
The matrix \( L_{ik} \) defined in Eq. \eqref{eq:lsum2} is then

$$
\begin{equation*}
   \hat{L}=\left(\begin{array} {cc} 1  & -\frac{1}{\sqrt{3}}\\
                                   1  & \frac{1}{\sqrt{3}}\end{array}\right),
\end{equation*}
$$

with an inverse given by

$$
\begin{equation*}
   \hat{L}^{-1}=\frac{\sqrt{3}}{2}\left(\begin{array} {cc} \frac{1}{\sqrt{3}}  & \frac{1}{\sqrt{3}}\\
                                   -1  & 1\end{array}\right).
\end{equation*}
$$

The weights are given by the matrix elements \( 2(L_{0k})^{-1} \). We have thence
\( \omega_0=1 \) and \( \omega_1=1 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec56">Application to the case \( N=2 \) </h2>
Obviously, there is no problem in changing the numbering of the matrix elements \( i,k=0,1,2,\dots,N-1 \) to
\( i,k=1,2,\dots,N \).  We have chosen to start from zero, since we deal with polynomials of degree \( N-1 \).

<p>
Summarizing, for Legendre polynomials with \( N=2 \) we have
weights
$$
\begin{equation*}
   \omega : \left\{1,1\right\},
\end{equation*}
$$

and mesh points

$$
\begin{equation*}
   x : \left\{-\frac{1}{\sqrt{3}},\frac{1}{\sqrt{3}}\right\}.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec57">Application to the case \( N=2 \) </h2>
If we wish to integrate
$$
\begin{equation*}
   \int_{-1}^1f(x)dx,
\end{equation*}
$$

with \( f(x)=x^2 \), we approximate
$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx \approx \sum_{i=0}^{N-1}\omega_ix_i^2.  
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec58">Application to the case \( N=2 \) </h2>
The exact answer is \( 2/3 \). Using \( N=2 \) with the above two weights 
and mesh points we get

$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx =\sum_{i=0}^{1}\omega_ix_i^2=\frac{1}{3}+\frac{1}{3}=\frac{2}{3},  
\end{equation*}
$$

the exact answer!

<p>
If we were to emply the trapezoidal rule we would get

$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx =\frac{b-a}{2}\left((a)^2+(b)^2\right)/2=
                       \frac{1-(-1)}{2}\left((-1)^2+(1)^2\right)/2=1!
\end{equation*}
$$

With just two points we can calculate exactly the integral for a second-order
polynomial since our methods approximates the exact function with higher
order polynomial. 
How many points do you need with the trapezoidal rule in order to achieve a
similar accuracy?

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec59">General integration intervals for Gauss-Legendre </h2>

<p>
Note that the Gauss-Legendre method is not limited
to an interval [-1,1], since we can always through a change of variable
$$
\begin{equation*}
   t=\frac{b-a}{2}x+\frac{b+a}{2},
\end{equation*}
$$

rewrite  the integral for an interval  [a,b]

$$
\begin{equation*}
  \int_a^bf(t)dt=\frac{b-a}{2}\int_{-1}^1f\left(\frac{(b-a)x}{2}+\frac{b+a}{2}\right)dx.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec60">Mapping integration points and weights </h2>
If we have an integral on the form
$$
\begin{equation*}
  \int_0^{\infty}f(t)dt,
\end{equation*}
$$

we can choose new mesh points and weights by using the mapping

$$
\begin{equation*}
\tilde{x}_i=tan\left\{\frac{\pi}{4}(1+x_i)\right\},
\end{equation*}
$$

and

$$
\begin{equation*}
\tilde{\omega}_i= \frac{\pi}{4}\frac{\omega_i}{cos^2\left(\frac{\pi}{4}(1+x_i)\right)},
\end{equation*}
$$

where \( x_i \) and \( \omega_i \) are the original mesh points and weights in the 
interval \( [-1,1] \), while \( \tilde{x}_i \) and \( \tilde{\omega}_i \) are the new
mesh points and weights for the interval \( [0,\infty) \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec61">Mapping integration points and weights </h2>
To see  that this is correct by inserting the 
the value of \( x_i=-1 \) (the lower end of the interval \( [-1,1] \))
into the expression for \( \tilde{x}_i \). That gives \( \tilde{x}_i=0 \),
the lower end of the interval \( [0,\infty) \). For
\( x_i=1 \), we obtain \( \tilde{x}_i=\infty \). To check that the new
weights are correct, recall that the weights should correspond to the 
derivative of the mesh points. Try to convince yourself that the
above expression fulfills this condition.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec62">Other orthogonal polynomials, Laguerre polynomials </h2>

<p>
If we are able to rewrite our integral of Eq.  \eqref{eq:generalint} with a
weight function \( W(x)=x^{\alpha}e^{-x} \) with integration limits 
\( [0,\infty) \), we could then use the Laguerre polynomials.
The polynomials form then the basis for the Gauss-Laguerre method which can be applied
to integrals of the form

$$
\begin{equation*} 
   I=\int_0^{\infty}f(x)dx =\int_0^{\infty}x^{\alpha}e^{-x}g(x)dx.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec63">Other orthogonal polynomials, Laguerre polynomials </h2>
These polynomials arise from the solution of the differential
equation

$$
\begin{equation*}
\left(\frac{d^2 }{dx^2}-\frac{d }{dx}+\frac{\lambda}{x}-\frac{l(l+1)}{x^2}\right){\cal L}(x)=0,
\end{equation*}
$$

where \( l \) is an integer \( l\ge 0 \) and \( \lambda \) a constant. This equation
arises for example from the solution of the radial Schr\"odinger equation with 
a centrally symmetric potential such as the Coulomb potential.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec64">Other orthogonal polynomials, Laguerre polynomials </h2>
The first few polynomials are
$$
\begin{equation*}
   {\cal L}_0(x)=1,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_1(x)=1-x,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_2(x)=2-4x+x^2,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_3(x)=6-18x+9x^2-x^3,
\end{equation*}
$$

and
$$
\begin{equation*}
    {\cal L}_4(x)=x^4-16x^3+72x^2-96x+24.
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec65">Other orthogonal polynomials, Laguerre polynomials </h2>
They fulfil the orthogonality relation
$$
\begin{equation*}
  \int_{0}^{\infty}e^{-x}{\cal L}_n(x)^2dx=1,
\end{equation*}
$$

and the recursion relation
$$
\begin{equation*}
  (n+1){\cal L}_{n+1}(x)=(2n+1-x){\cal L}_{n}(x)-n{\cal L}_{n-1}(x).
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec66">Other orthogonal polynomials, Hermite polynomials </h2>

<p>
In a similar way, for an integral which goes like
$$
\begin{equation*} 
   I=\int_{-\infty}^{\infty}f(x)dx =\int_{-\infty}^{\infty}e^{-x^2}g(x)dx.
\end{equation*}
$$

we could use the Hermite polynomials in order to extract weights and mesh points.
The Hermite polynomials are the solutions of the following differential
equation

$$
\begin{equation}
   \frac{d^2H(x)}{dx^2}-2x\frac{dH(x)}{dx}+
       (\lambda-1)H(x)=0.
\label{eq:hermite}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec67">Other orthogonal polynomials, Hermite polynomials </h2>
A typical example is again the solution of Schrodinger's
equation, but this time with a harmonic oscillator potential.
The first few polynomials are
$$
\begin{equation*}
   H_0(x)=1,
\end{equation*}
$$

$$
\begin{equation*}
    H_1(x)=2x,
\end{equation*}
$$

$$
\begin{equation*}
    H_2(x)=4x^2-2,
\end{equation*}
$$

$$
\begin{equation*}
    H_3(x)=8x^3-12,
\end{equation*}
$$

and
$$
\begin{equation*}
    H_4(x)=16x^4-48x^2+12.
\end{equation*}
$$

They fulfil the orthogonality relation
$$
\begin{equation*}
  \int_{-\infty}^{\infty}e^{-x^2}H_n(x)^2dx=2^nn!\sqrt{\pi},
\end{equation*}
$$

and the recursion relation
$$
\begin{equation*}
  H_{n+1}(x)=2xH_{n}(x)-2nH_{n-1}(x).
\end{equation*}
$$

<p>
<!-- !split  -->

<h2 id="___sec68">Demonstration of Gaussian Quadrature </h2>
Let us here compare three methods for integrating, namely the trapezoidal rule,
Simpson's method and the Gauss-Legendre approach. 
We choose two functions to integrate:
$$
\begin{equation*}
  \int_1^{100}\frac{\exp{(-x)}}{x}dx,
\end{equation*}
$$

and

$$
\begin{equation*}
  \int_{0}^{3}\frac{1}{2+x^2}dx.
\end{equation*}
$$

<p>
<!-- !split  -->

<h2 id="___sec69">Demonstration of Gaussian Quadrature, simple program </h2>
A program example which uses the trapezoidal rule, Simpson's rule
and the Gauss-Legendre method is included here. 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BC7A00">#include &lt;iostream&gt;</span>
<span style="color: #BC7A00">#include &quot;lib.h&quot;</span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;
<span style="color: #408080; font-style: italic">//     Here we define various functions called by the main program</span>
<span style="color: #408080; font-style: italic">//     this function defines the function to integrate</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">int_function</span>(<span style="color: #B00040">double</span> x);
<span style="color: #408080; font-style: italic">//   Main function begins here</span>
<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
     <span style="color: #B00040">int</span> n;
     <span style="color: #B00040">double</span> a, b;
     cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Read in the number of integration points&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
     cin <span style="color: #666666">&gt;&gt;</span> n;
     cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Read in integration limits&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
     cin <span style="color: #666666">&gt;&gt;</span> a <span style="color: #666666">&gt;&gt;</span> b;
<span style="color: #408080; font-style: italic">//   reserve space in memory for vectors containing the mesh points</span>
<span style="color: #408080; font-style: italic">//   weights and function values for the use of the gauss-legendre</span>
<span style="color: #408080; font-style: italic">//   method</span>
     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>x <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [n];
     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>w <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [n];
<span style="color: #408080; font-style: italic">//   set up the mesh points and weights</span>
     gauss_legendre(a, b,x,w, n);
<span style="color: #408080; font-style: italic">//   evaluate the integral with the Gauss-Legendre method</span>
<span style="color: #408080; font-style: italic">//   Note that we initialize the sum</span>
     <span style="color: #B00040">double</span> int_gauss <span style="color: #666666">=</span> <span style="color: #666666">0.</span>;
     <span style="color: #008000; font-weight: bold">for</span> ( <span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
        int_gauss<span style="color: #666666">+=</span>w[i]<span style="color: #666666">*</span>int_function(x[i]);
     }
<span style="color: #408080; font-style: italic">//    final output</span>
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Trapez-rule = &quot;</span> <span style="color: #666666">&lt;&lt;</span> trapezoidal_rule(a, b,n, int_function)
           <span style="color: #666666">&lt;&lt;</span> endl;
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Simpson&#39;s rule = &quot;</span> <span style="color: #666666">&lt;&lt;</span> simpson(a, b,n, int_function) 
           <span style="color: #666666">&lt;&lt;</span> endl;
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Gaussian quad = &quot;</span> <span style="color: #666666">&lt;&lt;</span> int_gauss <span style="color: #666666">&lt;&lt;</span> endl;
      <span style="color: #008000; font-weight: bold">delete</span> [] x;
      <span style="color: #008000; font-weight: bold">delete</span> [] w;
      <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}  <span style="color: #408080; font-style: italic">// end of main program</span>
<span style="color: #408080; font-style: italic">//  this function defines the function to integrate</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">int_function</span>(<span style="color: #B00040">double</span> x)
{
  <span style="color: #B00040">double</span> value <span style="color: #666666">=</span> <span style="color: #666666">4./</span>(<span style="color: #666666">1.+</span>x<span style="color: #666666">*</span>x);
  <span style="color: #008000; font-weight: bold">return</span> value;
} <span style="color: #408080; font-style: italic">// end of function to evaluate</span>
</pre></div>
<p>
<!-- !split  -->

<h2 id="___sec70">Demonstration of Gaussian Quadrature </h2>
To be noted in this program is that we can transfer the name of a given function to integrate.
In the table here we show the results for the first integral using various 
mesh points,.

<p>
<table border="1">
<thead>
<tr><td align="center">\( N \)</td> <th align="center"> Trapez </th> <th align="center">Simpson </th> <th align="center">Gauss-Legendre</th> </tr>
</thead>
<tbody>
<tr><td align="right">   10         </td> <td align="left">   1.821020    </td> <td align="left">   1.214025    </td> <td align="left">   0.1460448         </td> </tr>
<tr><td align="right">   20         </td> <td align="left">   0.912678    </td> <td align="left">   0.609897    </td> <td align="left">   0.2178091         </td> </tr>
<tr><td align="right">   40         </td> <td align="left">   0.478456    </td> <td align="left">   0.333714    </td> <td align="left">   0.2193834         </td> </tr>
<tr><td align="right">   100        </td> <td align="left">   0.273724    </td> <td align="left">   0.231290    </td> <td align="left">   0.2193839         </td> </tr>
<tr><td align="right">   1000       </td> <td align="left">   0.219984    </td> <td align="left">   0.219387    </td> <td align="left">   0.2193839         </td> </tr>
</tbody>
</table>
<p>
We note here that, since the area over where we integrate is rather large and the integrand 
goes slowly to zero for large values of \( x \), both the trapezoidal rule and Simpson's method
need quite many points in order to approach the Gauss-Legendre method. 
This integrand demonstrates clearly the strength of the Gauss-Legendre method
(and other GQ methods as well), viz., few points
are needed in order to achieve a very high precision.

<p>
<!-- !split  -->

<h2 id="___sec71">Demonstration of Gaussian Quadrature </h2>
The second table however shows that for smaller integration intervals, both the trapezoidal rule
and Simpson's method compare well with the results obtained with the Gauss-Legendre
approach.

<p>
<table border="1">
<thead>
<tr><td align="center">\( N \)</td> <th align="center"> Trapez </th> <th align="center">Simpson </th> <th align="center">Gauss-Legendre</th> </tr>
</thead>
<tbody>
<tr><td align="right">   10         </td> <td align="left">   0.798861    </td> <td align="left">   0.799231    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   20         </td> <td align="left">   0.799140    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   40         </td> <td align="left">   0.799209    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   100        </td> <td align="left">   0.799229    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   1000       </td> <td align="left">   0.799233    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
</tbody>
</table>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec72">Comparing methods and using symbolic Python </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The following python code allows you to run interactively either in a browser or using ipython notebook. It compares the trapezoidal rule and Gaussian quadrature with the exact result from symbolic python <b>SYMPY</b> up to 1000 integration points for the integral
$$
I = 2 = \int_0^{\infty} x^2 \exp{-x} dx.
$$

For the trapezoidal rule the results will vary strongly depending on how the infinity limit is approximated. Try to run the code below for different finite approximations to \( \infty \).
<p>


<div class="compute"><script type="text/x-sage">
from math import exp
import numpy as np
from sympy import Symbol, integrate, exp, oo

# function for the trapezoidal rule
def TrapezoidalRule(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s

# function for the Gaussian quadrature with Laguerre polynomials
def GaussLaguerreRule(n):
   s = 0
   xgauleg, wgauleg = np.polynomial.laguerre.laggauss(n)
   for i in range(1,n,1):
       s = s+ xgauleg[i]*xgauleg[i]*wgauleg[i]
   return s

#  function to compute
def function(x):
    return x*x*exp(-x)


# Integration limits for the Trapezoidal rule
a = 0.0; b = 10000.0
# define x as a symbol to be used by sympy
x = Symbol('x')
# find result from sympy
exact = integrate(function(x), (x, a, oo))
# set up the arrays for plotting the relative error
n = np.zeros(40); Trapez = np.zeros(4); LagGauss = np.zeros(4);
# find the relative error as function of integration points
for i in range(1, 3, 1):
    npts = 10**i
    n[i] = npts
    Trapez[i] = abs((TrapezoidalRule(a,b,function,npts)-exact)/exact)
    LagGauss[i] = abs((GaussLaguerreRule(npts)-exact)/exact)
print "Integration points=", n[1], n[2]
print "Trapezoidal relative error=", Trapez[1], Trapez[2]
print "LagGuass relative error=", LagGauss[1], LagGauss[2]



</script></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec73">Treatment of Singular Integrals </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
So-called principal value (PV) integrals are often employed in physics,
from Green's functions for scattering to dispersion relations.
Dispersion relations are often related to measurable quantities
and provide important consistency checks in atomic, nuclear and
particle physics. 
A PV integral is defined as
$$
\begin{equation*}
   I(x)={\cal P}\int_a^bdt\frac{f(t)}{t-x}=\lim_{\epsilon\rightarrow 0^+}
\left[\int_a^{x-\epsilon}dt\frac{f(t)}{t-x}+\int_{x+\epsilon}^bdt\frac{f(t)}{t-x}\right],
\end{equation*}
$$

and 
arises in applications
of Cauchy's residue theorem when the pole \( x \)  lies 
on the real axis within the interval of integration \( [a,b] \). Here \( {\cal P} \) stands for the principal value. <em>An important assumption is that the function \( f(t) \) is continuous 
on the interval of integration</em>.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec74">Treatment of Singular Integrals </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In case \( f(t) \) is a closed form expression or it has an analytic continuation
in the complex plane, it may be  possible to obtain an expression on closed
form for the above integral.

<p>
However, the situation which we are often confronted with is that
\( f(t) \) is only known at some points \( t_i \) with corresponding
values \( f(t_i) \). In order to obtain \( I(x) \) we need to resort to a
numerical evaluation.

<p>
To evaluate such an integral, let us first rewrite it as
$$
\begin{equation*}
 {\cal P}\int_a^bdt\frac{f(t)}{t-x}=
\int_a^{x-\Delta}dt\frac{f(t)}{t-x}+\int_{x+\Delta}^bdt\frac{f(t)}{t-x}+
{\cal P}\int_{x-\Delta}^{x+\Delta}dt\frac{f(t)}{t-x},
\end{equation*}
$$

where we have isolated the principal value part in the last integral.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec75">Treatment of Singular Integrals, change of variables </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Defining a new variable \( u=t-x \), we can rewrite the principal value
integral as
$$
\begin{equation} 
I_{\Delta}(x)={\cal P}\int_{-\Delta}^{+\Delta}du\frac{f(u+x)}{u}.
\label{eq:deltaint}
\end{equation} 
$$

One possibility is to Taylor expand \( f(u+x) \) around \( u=0 \), and compute
derivatives to a certain order as we did for the Trapezoidal rule or
Simpson's rule. 
Since all terms with even powers of \( u \) in the Taylor expansion dissapear,
we have that
$$
\begin{equation*}
I_{\Delta}(x)\approx \sum_{n=0}^{N_{max}}f^{(2n+1)}(x)
                     \frac{\Delta^{2n+1}}{(2n+1)(2n+1)!}.
\end{equation*}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec76">Treatment of Singular Integrals, higher-order derivatives </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To evaluate higher-order derivatives may be both time 
consuming and delicate from a numerical point of view, since 
there is always the risk of loosing precision when calculating
derivatives numerically. Unless we have an analytic expression
for \( f(u+x) \) and can evaluate the derivatives in a closed form,
the above approach is not the preferred one.

<p>
Rather, we show here how to use the Gauss-Legendre method
to compute Eq. \eqref{eq:deltaint}. 
Let us first introduce a new variable \( s=u/\Delta \) and rewrite
Eq. \eqref{eq:deltaint} as   
$$
\begin{equation}
I_{\Delta}(x)={\cal P}\int_{-1}^{+1}ds\frac{f(\Delta s+x)}{s}.
\label{eq:deltaint2}
\end{equation}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec77">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The integration limits are now from \( -1 \) to \( 1 \), as for the Legendre
polynomials.
The principal value in Eq. \eqref{eq:deltaint2} is however rather tricky
to evaluate numerically, mainly since computers have limited
precision. We will here use a subtraction trick often used
when dealing with singular integrals in numerical calculations.
We introduce first the calculus relation
$$
\begin{equation*}
  \int_{-1}^{+1} \frac{ds}{s} =0.
\end{equation*}
$$

It means that the curve \( 1/(s) \) has equal and opposite
areas on both sides of the singular point \( s=0 \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec78">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we then note that \( f(x) \) is just a constant, we have also
$$
\begin{equation*}
  f(x)\int_{-1}^{+1} \frac{ds}{s}=\int_{-1}^{+1}f(x) \frac{ds}{s} =0.
\end{equation*}
$$

<p>
Subtracting this equation from 
Eq. \eqref{eq:deltaint2} yields
$$
\begin{equation}
I_{\Delta}(x)={\cal P}\int_{-1}^{+1}ds\frac{f(\Delta s+x)}{s}=\int_{-1}^{+1}ds\frac{f(\Delta s+x)-f(x)}{s},
\label{eq:deltaint3}
\end{equation}
$$

and the integrand is no longer singular since we have that 
\( \lim_{s \rightarrow 0} (f(s+x) -f(x))=0 \) and for the particular case
\( s=0 \) the integrand 
is now finite.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec79">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Eq. \eqref{eq:deltaint3} is now rewritten using the Gauss-Legendre
method resulting in
$$
\begin{equation}
\int_{-1}^{+1}ds\frac{f(\Delta s+x)-f(x)}{s}=\sum_{i=1}^{N}\omega_i\frac{f(\Delta s_i+x)-f(x)}{s_i},
\label{eq:deltaint4}
\end{equation}
$$

where \( s_i \) are the mesh points (\( N \) in total) and \( \omega_i \) are the weights.

<p>
In the selection of mesh points for  a PV integral, it is important
to use an even number of points, since an odd number of mesh
points always picks \( s_i=0 \) as one of the mesh points. The sum in
Eq. \eqref{eq:deltaint4} will then diverge.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec80">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Let us apply this method to the integral
$$
\begin{equation}
I(x)={\cal P}\int_{-1}^{+1}dt\frac{e^t}{t}.
\label{eq:deltaint5}
\end{equation}
$$

The integrand diverges at \( x=t=0 \). We
rewrite it using Eq. \eqref{eq:deltaint3} as
$$
\begin{equation}
{\cal P}\int_{-1}^{+1}dt\frac{e^t}{t}=\int_{-1}^{+1}\frac{e^t-1}{t},
\label{eq:deltaint6}
\end{equation}
$$

since \( e^x=e^0=1 \). With Eq. \eqref{eq:deltaint4} we have then
$$
\begin{equation}
\int_{-1}^{+1}\frac{e^t-1}{t}\approx \sum_{i=1}^{N}\omega_i\frac{e^{t_i}-1}{t_i}.
\label{eq:deltaint7}
\end{equation}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec81">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The exact results is \( 2.11450175075.... \). With just two mesh points we recall
from the previous subsection that \( \omega_1=\omega_2=1 \) and that the mesh points are the zeros of \( L_2(x) \), namely \( x_1=-1/\sqrt{3} \) and 
\( x_2=1/\sqrt{3} \). Setting \( N=2 \) and inserting these values in the last
equation gives

$$
\begin{equation*}
   I_2(x=0)=\sqrt{3}\left(e^{1/\sqrt{3}}-e^{-1/\sqrt{3}}\right)=2.1129772845.
\end{equation*}
$$

With six mesh points we get even the exact result to the tenth digit

$$
\begin{equation*}
   I_6(x=0)=2.11450175075!
\end{equation*}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec82">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We can repeat the above subtraction trick  for more complicated
integrands.
First we modify the integration limits to \( \pm \infty \) and use the fact
that

$$
\begin{equation*}
  \int_{-\infty}^{\infty} \frac{dk}{k-k_0}=
  \int_{-\infty}^{0} \frac{dk}{k-k_0}+
  \int_{0}^{\infty} \frac{dk}{k-k_0} =0.
\end{equation*}
$$

A change of variable \( u=-k \) in the integral with limits from \( -\infty \) to \( 0 \) gives

$$
\begin{equation*}
  \int_{-\infty}^{\infty} \frac{dk}{k-k_0}=
  \int_{\infty}^{0} \frac{-du}{-u-k_0}+
  \int_{0}^{\infty} \frac{dk}{k-k_0}=  \int_{0}^{\infty} \frac{dk}{-k-k_0}+
  \int_{0}^{\infty} \frac{dk}{k-k_0}=0.
\end{equation*}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec83">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
It means that the curve \( 1/(k-k_0) \) has equal and opposite
areas on both sides of the singular point \( k_0 \). If we break
the integral into one over positive \( k \) and one over 
negative \( k \), a change of variable \( k\rightarrow -k \) 
allows us to rewrite the last equation as

$$
\begin{equation*}
  \int_{0}^{\infty} \frac{dk}{k^2-k_0^2} =0.
\end{equation*}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec84">Treatment of Singular Integrals  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We can use this to express a principal values integral
as
$$
\begin{equation}
  {\cal P}\int_{0}^{\infty} \frac{f(k)dk}{k^2-k_0^2} =
  \int_{0}^{\infty} \frac{(f(k)-f(k_0))dk}{k^2-k_0^2},
\label{eq:trick_pintegral}
\end{equation}
$$

where the right-hand side is no longer singular at 
\( k=k_0 \), it is proportional to the derivative \( df/dk \),
and can be evaluated numerically as any other integral.

<p>
Such a trick is often used when evaluating integral  equations, as discussed in the next section.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec85">Hints concerning project 3   </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The ansatz for the wave function for two electrons is given by the product of two
\( 1s \) wave functions as 
$$
   \Psi({\bf r}_1,{\bf r}_2)  =   e^{-\alpha (r_1+r_2)}.
$$

The integral we need to solve is the quantum mechanical expectation value of the correlation
energy between two electrons, namely
$$
   I = \int_{-\infty}^{\infty} d{\bf r}_1d{\bf r}_2  e^{-2\alpha (r_1+r_2)}\frac{1}{|{\bf r}_1-{\bf r}_2|}.
$$


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec86">Hints concerning project 3, parts of code   </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>x <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [N];
     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>w <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [N];
<span style="color: #408080; font-style: italic">//   set up the mesh points and weights</span>
     gauleg(a,b,x,w, N);

<span style="color: #408080; font-style: italic">//   evaluate the integral with the Gauss-Legendre method</span>
<span style="color: #408080; font-style: italic">//   Note that we initialize the sum</span>
     <span style="color: #B00040">double</span> int_gauss <span style="color: #666666">=</span> <span style="color: #666666">0.</span>;
<span style="color: #408080; font-style: italic">//   six-double loops</span>
     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>N;i<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>;j<span style="color: #666666">&lt;</span>N;j<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> k <span style="color: #666666">=</span> <span style="color: #666666">0</span>;k<span style="color: #666666">&lt;</span>N;k<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> l <span style="color: #666666">=</span> <span style="color: #666666">0</span>;l<span style="color: #666666">&lt;</span>N;l<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> m <span style="color: #666666">=</span> <span style="color: #666666">0</span>;m<span style="color: #666666">&lt;</span>N;m<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> n <span style="color: #666666">=</span> <span style="color: #666666">0</span>;n<span style="color: #666666">&lt;</span>N;n<span style="color: #666666">++</span>){
        int_gauss<span style="color: #666666">+=</span>w[i]<span style="color: #666666">*</span>w[j]<span style="color: #666666">*</span>w[k]<span style="color: #666666">*</span>w[l]<span style="color: #666666">*</span>w[m]<span style="color: #666666">*</span>w[n]
       <span style="color: #666666">*</span>int_function(x[i],x[j],x[k],x[l],x[m],x[n]);
     		}}}}}
	}
</pre></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec87">Hints concerning project 3, the function to integrate   </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic">//  this function defines the function to integrate</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">int_function</span>(<span style="color: #B00040">double</span> x1, <span style="color: #B00040">double</span> y1, <span style="color: #B00040">double</span> z1, <span style="color: #B00040">double</span> x2, <span style="color: #B00040">double</span> y2, <span style="color: #B00040">double</span> z2)
{
   <span style="color: #B00040">double</span> alpha <span style="color: #666666">=</span> <span style="color: #666666">2.</span>;
<span style="color: #408080; font-style: italic">// evaluate the different terms of the exponential</span>
   <span style="color: #B00040">double</span> exp1<span style="color: #666666">=-2*</span>alpha<span style="color: #666666">*</span>sqrt(x1<span style="color: #666666">*</span>x1<span style="color: #666666">+</span>y1<span style="color: #666666">*</span>y1<span style="color: #666666">+</span>z1<span style="color: #666666">*</span>z1);
   <span style="color: #B00040">double</span> exp2<span style="color: #666666">=-2*</span>alpha<span style="color: #666666">*</span>sqrt(x2<span style="color: #666666">*</span>x2<span style="color: #666666">+</span>y2<span style="color: #666666">*</span>y2<span style="color: #666666">+</span>z2<span style="color: #666666">*</span>z2);
   <span style="color: #B00040">double</span> deno<span style="color: #666666">=</span>sqrt(pow((x1<span style="color: #666666">-</span>x2),<span style="color: #666666">2</span>)<span style="color: #666666">+</span>pow((y1<span style="color: #666666">-</span>y2),<span style="color: #666666">2</span>)<span style="color: #666666">+</span>pow((z1<span style="color: #666666">-</span>z2),<span style="color: #666666">2</span>));
<span style="color: #408080; font-style: italic">// Cheating!!</span>
  <span style="color: #008000; font-weight: bold">if</span>(deno <span style="color: #666666">&lt;</span>pow(<span style="color: #666666">10.</span>,<span style="color: #666666">-6.</span>)) { <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;}
  <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">return</span> exp(exp1<span style="color: #666666">+</span>exp2)<span style="color: #666666">/</span>deno;
} <span style="color: #408080; font-style: italic">// end of function to evaluate</span>
</pre></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec88">Hints concerning project 3, Laguerre polynomials   </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Using Legendre polynomials for the Gaussian quadrature is not very efficient. There are several reasons for this:

<ul>
<li> You can easily end up in situations where the integrand diverges</li>
<li> The limits \( \pm \infty \) have to be approximated with a finite number</li>
</ul>

You will find it useful to change to spherical coordinates
$$
   d{\bf r}_1d{\bf r}_2  = r_1^2dr_1 r_2^2dr_2 dcos(\theta_1)dcos(\theta_2)d\phi_1d\phi_2,
$$

and
$$
   \frac{1}{r_{12}}= \frac{1}{\sqrt{r_1^2+r_2^2-2r_1r_2cos(\beta)}}
$$

with
$$
\cos(\beta) = \cos(\theta_1)\cos(\theta_2)+\sin(\theta_1)\sin(\theta_2)\cos(\phi_1-\phi_2))
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec89">Hints concerning project 3, Laguerre polynomials, the new integrand   </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
This means that our integral becomes
$$
I=\int_0^{\infty} r_1^2dr_1 \int_0^{\infty}r_2^2dr_2 \int_0^{\pi}dcos(\theta_1)\int_0^{\pi}dcos(\theta_2)\int_0^{2\pi}d\phi_1\int_0^{2\pi}d\phi_2  \frac{e^{-2\alpha (r_1+r_2)}}{r_{12}}
$$

where we have defined
$$
   \frac{1}{r_{12}}= \frac{1}{\sqrt{r_1^2+r_2^2-2r_1r_2cos(\beta)}}
$$

with 
$$
\cos(\beta) = \cos(\theta_1)\cos(\theta_2)+\sin(\theta_1)\sin(\theta_2)\cos(\phi_1-\phi_2))
$$
</div>


<p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2016, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

