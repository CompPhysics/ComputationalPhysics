<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computational Physics:  Teach yourself C++">

<title>Computational Physics:  Teach yourself C++</title>

<!-- Bootstrap style: bootstrap -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Getting Started, compiling and linking first',
               2,
               None,
               '___sec0'),
              ('Brief summary', 2, None, '___sec1'),
              ('From decimal to binary representation', 3, None, '___sec2'),
              ('Technical Matter in C/C++: Pointers', 2, None, '___sec3'),
              ('Using _strings_ instead of characters', 2, None, '___sec4'),
              ('Matrices in C++', 2, None, '___sec5'),
              ('"How to use the Library functions":"https://github.com/CompPhysics/ComputationalPhysicsMSU/tree/master/doc/Programs/LecturePrograms/programs/cppLibrary"',
               2,
               None,
               '___sec6'),
              ('"Using Armadillo to perform an LU decomposition":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/CppQtCodesLectures/MatrixTest/main.cpp"',
               2,
               None,
               '___sec7'),
              ('Optimization and profiling', 2, None, '___sec8'),
              ('Vectorization and the basic idea behind parallel computing',
               2,
               None,
               '___sec9'),
              ('What is vectorization?', 2, None, '___sec10'),
              ('"A simple test case with and without vectorization":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program7.cpp"',
               2,
               None,
               '___sec11'),
              ('Measuring performance', 2, None, '___sec12'),
              ('Problems with measuring time', 2, None, '___sec13'),
              ('Problems with cold start', 2, None, '___sec14'),
              ('Problems with smart compilers', 2, None, '___sec15'),
              ('Problems with interference', 2, None, '___sec16'),
              ('Problems with measuring performance', 2, None, '___sec17'),
              ('Thomas algorithm for tridiagonal linear algebra equations',
               2,
               None,
               '___sec18'),
              ('"The specialized Thomas algorithm (Project 1)":"https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Projects/2016/Project1/Examples/TridiagonalTiming.cpp"',
               2,
               None,
               '___sec19'),
              ('"Example: Transpose of a matrix":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program8.cpp"',
               2,
               None,
               '___sec20'),
              ('"Matrix-matrix multiplication":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program9.cpp"',
               2,
               None,
               '___sec21'),
              ('How do we define speedup? Simplest form',
               2,
               None,
               '___sec22'),
              ('Object orientation', 2, None, '___sec23'),
              ('Object orientation', 2, None, '___sec24'),
              ('Programming classes', 2, None, '___sec25'),
              ('Programming classes', 2, None, '___sec26'),
              ('Programming classes', 2, None, '___sec27'),
              ('Programming classes', 2, None, '___sec28'),
              ('Programming classes', 2, None, '___sec29'),
              ('Programming classes', 2, None, '___sec30'),
              ('Programming classes', 2, None, '___sec31'),
              ('Programming classes', 2, None, '___sec32'),
              ('Programming classes', 2, None, '___sec33'),
              ('Programming classes', 2, None, '___sec34'),
              ('Programming classes', 2, None, '___sec35'),
              ('Programming classes', 2, None, '___sec36'),
              ('Programming classes', 2, None, '___sec37'),
              ('Programming classes', 2, None, '___sec38'),
              ('Programming classes', 2, None, '___sec39'),
              ('Programming classes', 2, None, '___sec40'),
              ('Programming classes', 2, None, '___sec41'),
              ('Programming classes', 2, None, '___sec42'),
              ('Programming classes', 2, None, '___sec43'),
              ('Programming classes', 2, None, '___sec44'),
              ('Programming classes', 2, None, '___sec45'),
              ('Programming classes', 2, None, '___sec46'),
              ('Programming classes', 2, None, '___sec47'),
              ('Programming classes', 2, None, '___sec48'),
              ('Programming classes', 2, None, '___sec49'),
              ('Programming classes', 2, None, '___sec50'),
              ('Programming classes', 2, None, '___sec51'),
              ('Programming classes', 2, None, '___sec52'),
              ('Programming classes', 2, None, '___sec53'),
              ('Programming classes', 2, None, '___sec54'),
              ('Programming classes', 2, None, '___sec55'),
              ('Programming classes', 2, None, '___sec56'),
              ('Programming classes', 2, None, '___sec57'),
              ('Programming classes, templates', 2, None, '___sec58'),
              ('Programming classes', 2, None, '___sec59'),
              ('Programming classes', 2, None, '___sec60'),
              ('Programming classes', 2, None, '___sec61'),
              ('Programming classes', 2, None, '___sec62'),
              ('Programming classes', 2, None, '___sec63'),
              ('Programming classes', 2, None, '___sec64'),
              ('A matrix-vector class, first its usage', 2, None, '___sec65'),
              ('A matrix-vector class, the class definitions themselves',
               2,
               None,
               '___sec66'),
              ('A matrix-vector class, and finally all its functions',
               2,
               None,
               '___sec67')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="learningcpp-bs.html">Computational Physics:  Teach yourself C++</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec0" style="font-size: 80%;"><b>Getting Started, compiling and linking first</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec1" style="font-size: 80%;"><b>Brief summary</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;From decimal to binary representation</a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec3" style="font-size: 80%;"><b>Technical Matter in C/C++: Pointers</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec4" style="font-size: 80%;"><b>Using <b>strings</b> instead of characters</b></a></li>
     <!-- navigation toc: --> <li><a href="._learningcpp-bs000.html#___sec5" style="font-size: 80%;"><b>Matrices in C++</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;"><b>"How to use the Library functions":"https://github.com/CompPhysics/ComputationalPhysicsMSU/tree/master/doc/Programs/LecturePrograms/programs/cppLibrary"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec7" style="font-size: 80%;"><b>"Using Armadillo to perform an LU decomposition":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/CppQtCodesLectures/MatrixTest/main.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;"><b>Optimization and profiling</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;"><b>Vectorization and the basic idea behind parallel computing</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;"><b>What is vectorization?</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;"><b>"A simple test case with and without vectorization":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program7.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;"><b>Measuring performance</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;"><b>Problems with measuring time</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;"><b>Problems with cold start</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;"><b>Problems with smart compilers</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;"><b>Problems with interference</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;"><b>Problems with measuring performance</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;"><b>Thomas algorithm for tridiagonal linear algebra equations</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;"><b>"The specialized Thomas algorithm (Project 1)":"https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Projects/2016/Project1/Examples/TridiagonalTiming.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec20" style="font-size: 80%;"><b>"Example: Transpose of a matrix":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program8.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec21" style="font-size: 80%;"><b>"Matrix-matrix multiplication":"https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program9.cpp"</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;"><b>How do we define speedup? Simplest form</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec23" style="font-size: 80%;"><b>Object orientation</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec24" style="font-size: 80%;"><b>Object orientation</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec25" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec26" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec27" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec28" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec29" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec30" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec31" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec32" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec33" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec34" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec35" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec36" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec37" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec38" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec39" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec40" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec41" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec42" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec43" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec44" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec45" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec46" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec47" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec48" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec49" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec50" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec51" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec52" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec53" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec54" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec55" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec57" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec58" style="font-size: 80%;"><b>Programming classes, templates</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec59" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec60" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec61" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec62" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec63" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec64" style="font-size: 80%;"><b>Programming classes</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec65" style="font-size: 80%;"><b>A matrix-vector class, first its usage</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec66" style="font-size: 80%;"><b>A matrix-vector class, the class definitions themselves</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec67" style="font-size: 80%;"><b>A matrix-vector class, and finally all its functions</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0001"></a>
<!-- !split -->

<h2 id="___sec6" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/tree/master/doc/Programs/LecturePrograms/programs/cppLibrary" target="_self">How to use the Library functions</a> </h2>

<p>
Standard C/C++: fetch the files <code>lib.cpp</code> and <code>lib.h</code>. You can make a directory where you store
these files, and eventually its compiled version lib.o. The example here is <a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/LinAlgebra/cpp/program1.cpp" target="_self">program1.cpp from chapter 6</a> and performs the matrix inversion.

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">//  Simple matrix inversion example</span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;new&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstdio&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstdlib&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cmath&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cstring&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;lib.h&quot;</span><span style="color: #BC7A00"></span>

<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;

<span style="color: #408080; font-style: italic">/* function declarations */</span>

<span style="color: #B00040">void</span> <span style="color: #0000FF">inverse</span>(<span style="color: #B00040">double</span> <span style="color: #666666">**</span>, <span style="color: #B00040">int</span>);

<span style="color: #B00040">void</span> <span style="color: #0000FF">inverse</span>(<span style="color: #B00040">double</span> <span style="color: #666666">**</span>a, <span style="color: #B00040">int</span> n)
{
  <span style="color: #B00040">int</span>          i,j, <span style="color: #666666">*</span>indx;
  <span style="color: #B00040">double</span>       d, <span style="color: #666666">*</span>col, <span style="color: #666666">**</span>y;
  <span style="color: #408080; font-style: italic">// allocate space in memory</span>
  indx <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">int</span>[n];
  col  <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[n];
  y    <span style="color: #666666">=</span> (<span style="color: #B00040">double</span> <span style="color: #666666">**</span>) matrix(n, n, <span style="color: #008000; font-weight: bold">sizeof</span>(<span style="color: #B00040">double</span>));
  ludcmp(a, n, indx, <span style="color: #666666">&amp;</span>d);   <span style="color: #408080; font-style: italic">// LU decompose  a[][]</span>
  printf(<span style="color: #BA2121">&quot;</span><span style="color: #BB6622; font-weight: bold">\n\n</span><span style="color: #BA2121">LU form of matrix of a[][]:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>);
  <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
    printf(<span style="color: #BA2121">&quot;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>);
    <span style="color: #008000; font-weight: bold">for</span>(j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
      printf(<span style="color: #BA2121">&quot; a[%2d][%2d] = %12.4E&quot;</span>,i, j, a[i][j]);
  <span style="color: #408080; font-style: italic">// find inverse of a[][] by columns</span>
  <span style="color: #008000; font-weight: bold">for</span>(j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    <span style="color: #408080; font-style: italic">// initialize right-side of linear equations</span>
    <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) col[i] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    col[j] <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>;
    lubksb(a, n, indx, col);
    <span style="color: #408080; font-style: italic">// save result in y[][]</span>
    <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) y[i][j] <span style="color: #666666">=</span> col[i];
  }   <span style="color: #408080; font-style: italic">//j-loop over columns</span>
  <span style="color: #408080; font-style: italic">// return the inverse matrix in a[][]</span>
  <span style="color: #008000; font-weight: bold">for</span>(i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
    <span style="color: #008000; font-weight: bold">for</span>(j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) a[i][j] <span style="color: #666666">=</span> y[i][j];

  free_matrix((<span style="color: #B00040">void</span> <span style="color: #666666">**</span>) y);     <span style="color: #408080; font-style: italic">// release local memory</span>
  <span style="color: #008000; font-weight: bold">delete</span> [] col;
  <span style="color: #008000; font-weight: bold">delete</span> []indx;
}  <span style="color: #408080; font-style: italic">// End: function inverse()</span>
</pre></div>

<h2 id="___sec7" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/CppQtCodesLectures/MatrixTest/main.cpp" target="_self">Using Armadillo to perform an LU decomposition</a> </h2>
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;armadillo&quot;</span><span style="color: #BC7A00"></span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> arma;
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
  {
   mat A <span style="color: #666666">=</span> randu<span style="color: #666666">&lt;</span>mat<span style="color: #666666">&gt;</span>(<span style="color: #666666">5</span>,<span style="color: #666666">5</span>);
   vec b <span style="color: #666666">=</span> randu<span style="color: #666666">&lt;</span>vec<span style="color: #666666">&gt;</span>(<span style="color: #666666">5</span>);

  A.print(<span style="color: #BA2121">&quot;A =&quot;</span>);
  b.print(<span style="color: #BA2121">&quot;b=&quot;</span>);
  <span style="color: #408080; font-style: italic">// solve Ax = b</span>
  vec x <span style="color: #666666">=</span> solve(A,b);
  <span style="color: #408080; font-style: italic">// print x</span>
  x.print(<span style="color: #BA2121">&quot;x=&quot;</span>);
  <span style="color: #408080; font-style: italic">// find LU decomp of A, if needed, P is the permutation matrix</span>
  mat L, U;
  lu(L,U,A);
  <span style="color: #408080; font-style: italic">// print l</span>
  L.print(<span style="color: #BA2121">&quot; L= &quot;</span>);
  <span style="color: #408080; font-style: italic">// print U</span>
  U.print(<span style="color: #BA2121">&quot; U= &quot;</span>);
  <span style="color: #408080; font-style: italic">//Check that A = LU</span>
  (A<span style="color: #666666">-</span>P<span style="color: #666666">*</span>L<span style="color: #666666">*</span>U).print(<span style="color: #BA2121">&quot;Test of LU decomposition&quot;</span>);
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
  }
</pre></div>

<h2 id="___sec8" class="anchor">Optimization and profiling </h2>

<p>
Till now we have not paid much attention to speed and possible optimization possibilities
inherent in the various compilers. We have compiled and linked as
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
For Fortran replace with for example <b>gfortran</b> or <b>ifort</b>.
This is what we call a flat compiler option and should be used when we develop the code.
It produces normally a very large and slow code when translated to machine instructions.
We use this option for debugging and for establishing the correct program output because
every operation is done precisely as the user specified it.

<p>
It is instructive to look up the compiler manual for further instructions by writing
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>man c<span style="color: #666666">++</span>
</pre></div>
<p>
We have additional compiler options for optimization. These may include procedure inlining where 
performance may be improved, moving constants inside loops outside the loop, 
identify potential parallelism, include automatic vectorization or replace a division with a reciprocal
and a multiplication if this speeds up the code.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
This (other options are -O2 or -Ofast) is the recommended option.

<p>
It is also useful to profile your program under the development stage.
You would then compile with 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>pg <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>pg <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
After you have run the code you can obtain the profiling information via
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>gprof mycode.exe <span style="color: #666666">&gt;</span>  ProfileOutput
</pre></div>
<p>
When you have profiled properly your code, you must take out this option as it 
slows down performance.
For memory tests use <a href="http://www.valgrind.org" target="_self">valgrind</a>. An excellent environment for all these aspects, and much  more, is  Qt creator.

<p>
Adding debugging options is a very useful alternative under the development stage of a program.
You would then compile with 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>g <span style="color: #666666">-</span>O0 <span style="color: #666666">-</span>c  mycode.cpp
c<span style="color: #666666">++</span>  <span style="color: #666666">-</span>g <span style="color: #666666">-</span>O0 <span style="color: #666666">-</span>o  mycode.exe  mycode.o
</pre></div>
<p>
This option generates debugging information allowing you to trace for example if an array is properly allocated. Some compilers work best with the no optimization option <b>-O0</b>.

<p>
Depending on the compiler, one can add flags which generate code that catches integer overflow errors. 
The flag <b>-ftrapv</b> does this for the CLANG compiler on OS X operating systems.

<p>
In general, irrespective of compiler options, it is useful to

<ul>
<li> avoid if tests or call to functions inside loops, if possible.</li> 
<li> avoid multiplication with constants inside loops if possible</li>
</ul>

Here is an example of a part of a program where specific operations lead to a slower code
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>k <span style="color: #666666">=</span> n<span style="color: #666666">-1</span>;
<span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span>c<span style="color: #666666">*</span>d;
    e <span style="color: #666666">=</span> g[k];
}
</pre></div>
<p>
A better code is
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>temp <span style="color: #666666">=</span> c<span style="color: #666666">*</span>d;
<span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> temp;
}
e <span style="color: #666666">=</span> g[n<span style="color: #666666">-1</span>];
</pre></div>
<p>
Here we avoid a repeated multiplication inside a loop. 
Most compilers, depending on compiler flags, identify and optimize such bottlenecks on their own, without requiring any particular action by the programmer. However, it is always useful to single out and avoid code examples like the first one discussed here.

<h2 id="___sec9" class="anchor">Vectorization and the basic idea behind parallel computing </h2>

<p>
Present CPUs are highly parallel processors with varying levels of parallelism. The typical situation can be described via the following three statements.

<ul>
<li> Pursuit of shorter computation time and larger simulation size gives rise to parallel computing.</li>
<li> Multiple processors are involved to solve a global problem.</li>
<li> The essence is to divide the entire computation evenly among collaborative processors.  Divide and conquer.</li>
</ul>

Before we proceed with a more detailed discussion of topics like vectorization and parallelization, we need to remind ourselves about some basic features of different hardware models. We have

<ul>
<li> Conventional single-processor computers are named SISD (single-instruction-single-data) machines.</li>
<li> SIMD (single-instruction-multiple-data) machines incorporate the idea of parallel processing, using a large number of processing units to execute the same instruction on different data.</li>
<li> Modern parallel computers are so-called MIMD (multiple-instruction-multiple-data) machines and can execute different instruction streams in parallel on different data.</li>
</ul>

<h2 id="___sec10" class="anchor">What is vectorization? </h2>

<p>
Vectorization is a special
case of <b>Single Instructions Multiple Data</b> (SIMD) to denote a single
instruction stream capable of operating on multiple data elements in
parallel. 
We can think of vectorization as the unrolling of loops accompanied with SIMD instructions.

<p>
Vectorization is the process of converting an algorithm that performs scalar operations
(typically one operation at the time) to vector operations where a single operation can refer to many simultaneous operations.
Consider the following example
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> c[i];
}
</pre></div>
<p>
If the code is not vectorized, the compiler will simply start with the first element and 
then perform subsequent additions operating on one address in memory at the time.

<p>
A SIMD instruction can operate  on multiple data elements in one single instruction.
It uses the so-called 128-bit SIMD floating-point register. 
In this sense,vectorization adds some form of parallelism since one instruction is applied  
to many parts of say a vector.

<p>
The number of elements which can be operated on in parallel
range from four single-precision floating point data elements in so-called 
Streaming SIMD Extensions and two double-precision floating-point data
elements in Streaming SIMD Extensions 2 to sixteen byte operations in
a 128-bit register in Streaming SIMD Extensions 2. Thus, vector-length
ranges from 2 to 16, depending on the instruction extensions used and
on the data type.

<p>
We start with the simple scalar operations given by
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> c[i];
}
</pre></div>
<p>
If the code is not vectorized  and we have a 128-bit register to store a 32 bits floating point number,
it means that we have \( 3\times 32 \) bits that are not used. For the first element we have

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  0  </b></td> <td align="center"><b>   1    </b></td> <td align="center"><b>   2    </b></td> <td align="center"><b>   3    </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   a[0]=    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> </tr>
<tr><td align="center">   b[0]+    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> </tr>
<tr><td align="center">   c[0]     </td> <td align="center">   not used    </td> <td align="center">   not used    </td> <td align="center">   not used    </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>
We have thus unused space in our SIMD registers. These registers could hold three additional integers.

<p>
If we vectorize the code, we can perform, with a 128-bit register four simultaneous operations, that is
we have
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> (i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">+=4</span>){
    a[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> c[i];
    a[i<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> b[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> c[i<span style="color: #666666">+1</span>];
    a[i<span style="color: #666666">+2</span>] <span style="color: #666666">=</span> b[i<span style="color: #666666">+2</span>] <span style="color: #666666">+</span> c[i<span style="color: #666666">+2</span>];
    a[i<span style="color: #666666">+3</span>] <span style="color: #666666">=</span> b[i<span style="color: #666666">+3</span>] <span style="color: #666666">+</span> c[i<span style="color: #666666">+3</span>];
}
</pre></div>
<p>
displayed here as

<p>

<div class="row">
  <div class="col-xs-2">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  0  </b></td> <td align="center"><b>  1  </b></td> <td align="center"><b>  2  </b></td> <td align="center"><b>  3  </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   a[0]=    </td> <td align="center">   a[1]=    </td> <td align="center">   a[2]=    </td> <td align="center">   a[3]=    </td> </tr>
<tr><td align="center">   b[0]+    </td> <td align="center">   b[1]+    </td> <td align="center">   b[2]+    </td> <td align="center">   b[3]+    </td> </tr>
<tr><td align="center">   c[0]     </td> <td align="center">   c[1]     </td> <td align="center">   c[2]     </td> <td align="center">   c[3]     </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-2 -->
</div> <!-- cell row -->
Four additions are now done in a single step.

<h2 id="___sec11" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program7.cpp" target="_self">A simple test case with and without vectorization</a> </h2>
We implement these operations in a simple c++ program as

<p>

<!-- code=text (!bc cppcode) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &quot;time.h&quot; 

using namespace std; // note use of namespace                                       
int main (int argc, char* argv[])
{
  int i = atoi(argv[1]); 
  double *a, *b, *c;
  a = new double[i]; 
  b = new double[i]; 
  c = new double[i]; 
  for (int j = 0; j &lt; i; j++) {
    a[j] = 0.0;
    b[j] = cos(j*1.0);
    c[j] = sin(j*3.0);
  }
  clock_t start, finish;
  start = clock();
  for (int j = 0; j &lt; i; j++) {
    a[j] = b[j]+b[j]*c[j];
  }
  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
  cout &lt;&lt; setiosflags(ios::showpoint | ios::uppercase);
  cout &lt;&lt; setprecision(10) &lt;&lt; setw(20) &lt;&lt; &quot;Time used  for vector addition and multiplication=&quot; &lt;&lt; timeused  &lt;&lt; endl;
  delete [] a;
  delete [] b;
  delete [] c;
  return 0;     
}
</pre></div>
<p>
We can compile and link without vectorization
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span> <span style="color: #666666">-</span>o novec.x vecexample.cpp
</pre></div>
<p>
vand with vectorization (and additional optimizations)
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
The speedup depends on the size of the vectors. In the example here we have run with \( 10^7 \) elements.
The example here was run on a PC with ubuntu 14.04 as operating system and an Intel i7-4790 CPU running at 3.60 GHz. 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>vec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> vector addition <span style="color: #666666">=</span> <span style="color: #666666">0.0100000</span>
<span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>novec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> vector addition <span style="color: #666666">=</span> <span style="color: #666666">0.03000000000</span>
</pre></div>
<p>
This particular C++ compiler speeds up the above loop operations with a factor of 3. 
Performing the same operations for \( 10^8 \) elements results only in a factor \( 1.4 \).
The result will however vary from compiler to compiler. In general however, with optimization flags like \( -O3 \) or \( -Ofast \), we gain a considerable speedup if our code can be vectorized. Many of these operations can be done automatically by your compiler. These automatic or near automatic compiler techniques improve performance considerably.

<p>
Not all loops can be vectorized, as discussed in <a href="https://software.intel.com/en-us/articles/a-guide-to-auto-vectorization-with-intel-c-compilers" target="_self">Intel's guide to vectorization</a>

<p>
An important criteria is that the loop counter \( n \) is known at the entry of the loop.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    a[j] <span style="color: #666666">=</span> cos(j<span style="color: #666666">*1.0</span>);
  }
</pre></div>
<p>
The variable \( n \) does need to be known at compile time. However, this variable must stay the same for the entire duration of the loop. It implies that an exit statement inside the loop cannot be data dependent.

<p>
An exit statement should in general be avoided. 
If the exit statement contains data-dependent conditions, the loop cannot be vectorized. 
The following is an example of a non-vectorizable loop
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    a[j] <span style="color: #666666">=</span> cos(j<span style="color: #666666">*1.0</span>);
    <span style="color: #008000; font-weight: bold">if</span> (a[j] <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span> ) <span style="color: #008000; font-weight: bold">break</span>;
  }
</pre></div>
<p>
Avoid loop termination conditions and opt for a single entry loop variable \( n \). The lower and upper bounds have to be kept fixed within the loop.

<p>
SIMD instructions perform the same type of operations multiple times. 
A <b>switch</b> statement leads thus to a non-vectorizable loop since different statemens cannot branch.
The following code can however be vectorized since the <b>if</b> statement is implemented as a masked assignment.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
    <span style="color: #B00040">double</span> x  <span style="color: #666666">=</span> cos(j<span style="color: #666666">*1.0</span>);
    <span style="color: #008000; font-weight: bold">if</span> (x <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span> ) {
       a[j] <span style="color: #666666">=</span>  x<span style="color: #666666">*</span>sin(j<span style="color: #666666">*2.0</span>); 
    }
    <span style="color: #008000; font-weight: bold">else</span> {
       a[j] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    }
  }
</pre></div>
<p>
These operations can be performed for all data elements but only those elements which the mask evaluates as true are stored. In general, one should avoid branches such as <b>switch</b>, <b>go to</b>, or <b>return</b> statements or <b>if</b> constructs that cannot be treated as masked assignments.

<p>
Only the innermost loop of the following example is vectorized
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
           a[i][j] <span style="color: #666666">+=</span> b[i][j];
      }  
  }
</pre></div>
<p>
The exception is if an original outer loop is transformed into an inner loop as the result of compiler optimizations.

<p>
Calls to programmer defined functions ruin vectorization. However, calls to intrinsic functions like
\( \sin{x} \), \( \cos{x} \), \( \exp{x} \) etc are allowed since they are normally efficiently vectorized. 
The following example is fully vectorizable
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      a[i] <span style="color: #666666">=</span> log10(i)<span style="color: #666666">*</span>cos(i);
  }
</pre></div>
<p>
Similarly, <b>inline</b> functions defined by the programmer, allow for vectorization since the function statements are glued into the actual place where the function is called.

<p>
One has to keep in mind that vectorization changes the order of operations inside a loop. A so-called
read-after-write statement with an explicit flow dependency cannot be vectorized. The following code
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #B00040">double</span> b <span style="color: #666666">=</span> <span style="color: #666666">15.</span>;
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">1</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      a[i] <span style="color: #666666">=</span> a[i<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> b;
  }
</pre></div>
<p>
is an example of flow dependency and results in wrong numerical results if vectorized. For a scalar operation, the value \( a[i-1] \) computed during the iteration is loaded into the right-hand side and the results are fine. In vector mode however, with a vector length of four, the values \( a[0] \), \( a[1] \), \( a[2] \) and \( a[3] \) from the previous loop will be loaded into the right-hand side and produce wrong results. That is, we have
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>   a[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> b;
   a[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> b;
   a[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">2</span>] <span style="color: #666666">+</span> b;
   a[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> a[<span style="color: #666666">3</span>] <span style="color: #666666">+</span> b;
</pre></div>
<p>
and if the two first iterations are  executed at the same by the SIMD instruction, the value of say \( a[1] \) could be used by the second iteration before it has been calculated by the first iteration, leading thereby to wrong results.

<p>
On the other hand,  a so-called 
write-after-read statement can be vectorized. The following code
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #B00040">double</span> b <span style="color: #666666">=</span> <span style="color: #666666">15.</span>;
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">1</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      a[i<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> a[i] <span style="color: #666666">+</span> b;
  }
</pre></div>
<p>
is an example of flow dependency that can be vectorized since no iteration with a higher value of \( i \)
can complete before an iteration with a lower value of \( i \). However, such code leads to problems with parallelization.

<p>
For C++ programmers  it is also worth keeping in mind that an array notation is preferred to the more compact use of pointers to access array elements. The compiler can often not tell if it is safe to vectorize the code.

<p>
When dealing with arrays, you should also avoid memory stride, since this slows down considerably vectorization. When you access array element, write for example the inner loop to vectorize using unit stride, that is, access successively the next array element in memory, as shown here
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;</span> n; j<span style="color: #666666">++</span>) {
           a[i][j] <span style="color: #666666">+=</span> b[i][j];
      }  
  }
</pre></div>
<p>
We can compile and link without vectorization using the clang c++ (on OSX for example) compiler
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang <span style="color: #666666">-</span>o novec.x vecexample.cpp
</pre></div>
<p>
and with vectorization (and additional optimizations)
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
The speedup depends on the size of the vectors. In the example here we have run with \( 10^7 \) elements.
The example here was run on an IMac17.1 with OSX El Capitan (10.11.4) as operating system and an Intel i5 3.3 GHz CPU.

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>vec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=0.04720500000</span>
<span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>novec.x <span style="color: #666666">10000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=0.03311700000</span>
</pre></div>
<p>
This particular C++ compiler speeds up the above loop operations with a factor of 1.5 
Performing the same operations for \( 10^9 \) elements results in a smaller speedup since reading from main memory is required. The non-vectorized code is seemingly faster. 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>vec.x <span style="color: #666666">1000000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=58.41391100</span>
<span style="color: #A0A000">Compphys</span>:<span style="color: #666666">~</span> hjensen$ .<span style="color: #666666">/</span>novec.x <span style="color: #666666">1000000000</span>
Time used  <span style="color: #008000; font-weight: bold">for</span> norm computation<span style="color: #666666">=46.51295300</span>
</pre></div>
<p>
We will discuss these issues below.

<p>
We can compile and link without vectorization with clang compiler
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>o <span style="color: #666666">-</span>fno<span style="color: #666666">-</span>vectorize novec.x vecexample.cpp
</pre></div>
<p>
and with vectorization
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
We can also add vectorization analysis, see for example
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">-</span>analysis<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>
<p>
or figure out if vectorization was missed
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>clang<span style="color: #666666">++</span> <span style="color: #666666">-</span>O3 <span style="color: #666666">-</span>Rpass<span style="color: #666666">-</span>missed<span style="color: #666666">=</span>loop<span style="color: #666666">-</span>vectorize <span style="color: #666666">-</span>o  vec.x vecexample.cpp 
</pre></div>

<h2 id="___sec12" class="anchor">Measuring performance </h2>

<p>
How do we measure erformance? What is wrong with this code to time a loop?
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  clock_t start, finish;
  start = clock();
  for (int j = 0; j &lt; i; j++) {
    a[j] = b[j]+b[j]*c[j];
  }
  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
</pre></div>

<h2 id="___sec13" class="anchor">Problems with measuring time </h2>

<ol>
<li> Timers are not infinitely accurate</li>
<li> All clocks have a granularity, the minimum time that they can measure</li>
<li> The error in a time measurement, even if everything is perfect, may be the size of this granularity (sometimes called a clock tick)</li>
<li> Always know what your clock granularity is</li>
<li> Ensure that your measurement is for a long enough duration (say 100 times the <b>tick</b>)</li>
</ol>

<h2 id="___sec14" class="anchor">Problems with cold start </h2>

<p>
What happens when the code is executed? The assumption is that the code is ready to
execute. But

<ol>
<li> Code may still be on disk, and not even read into memory.</li>
<li> Data may be in slow memory rather than fast (which may be wrong or right for what you are measuring)</li>
<li> Multiple tests often necessary to ensure that cold start effects are not present</li>
<li> Special effort often required to ensure data in the intended part of the memory hierarchy.</li>
</ol>

<h2 id="___sec15" class="anchor">Problems with smart compilers </h2>

<ol>
<li> If the result of the computation is not used, the compiler may eliminate the code</li>
<li> Performance will look impossibly fantastic</li>
<li> Even worse, eliminate some of the code so the performance looks plausible</li>
<li> Ensure that the results are (or may be) used.</li>
</ol>

<h2 id="___sec16" class="anchor">Problems with interference </h2>

<ol>
<li> Other activities are sharing your processor</li>

<ul>
  <li> Operating system, system demons, other users</li>

<ul>
   <li> Some parts of the hardware do not always perform with exactly the same performance</li>
</ul>

</ul>

<li> Make multiple tests and report</li>
<li> Easy choices include</li>

<ul>
  <li> Average tests represent what users might observe over time</li>
</ul>

</ol>

<h2 id="___sec17" class="anchor">Problems with measuring performance  </h2>

<ol>
<li> Accurate, reproducible performance measurement is hard</li>
<li> Think carefully about your experiment:</li>
<li> What is it, precisely, that you want to measure</li>
<li> How representative is your test to the situation that you are trying to measure?</li>
</ol>

<h2 id="___sec18" class="anchor">Thomas algorithm for tridiagonal linear algebra equations </h2>
$$
\left( \begin{array}{ccccc}
        b_0 & c_0 &        &         &         \\
	a_0 &  b_1 &  c_1    &         &         \\
	   &    & \ddots  &         &         \\
	      &	    & a_{m-3} & b_{m-2} & c_{m-2} \\
	         &    &         & a_{m-2} & b_{m-1}
   \end{array} \right)
\left( \begin{array}{c}
       x_0     \\
       x_1     \\
       \vdots  \\
       x_{m-2} \\
       x_{m-1}
   \end{array} \right)=\left( \begin{array}{c}
       f_0     \\
       f_1     \\
       \vdots  \\
       f_{m-2} \\
       f_{m-1} \\
   \end{array} \right)
$$

<p>
The first step is to multiply the first row by \( a_0/b_0 \) and subtract it from the second row.  This is known as the forward substitution step. We obtain then
$$
	a_i = 0,
$$


$$                                 
	b_i = b_i - \frac{a_{i-1}}{b_{i-1}}c_{i-1},
$$

and
$$
	f_i = f_i - \frac{a_{i-1}}{b_{i-1}}f_{i-1}.
$$

At this point the simplified equation, with only an upper triangular matrix takes the form
$$
\left( \begin{array}{ccccc}
    b_0 & c_0 &        &         &         \\
       & b_1 &  c_1    &         &         \\
          &    & \ddots &         &         \\
	     &     &        & b_{m-2} & c_{m-2} \\
	        &    &        &         & b_{m-1}
   \end{array} \right)\left( \begin{array}{c}
       x_0     \\
       x_1     \\
       \vdots  \\
       x_{m-2} \\
       x_{m-1}
   \end{array} \right)=\left( \begin{array}{c}
       f_0     \\
       f_1     \\
       \vdots  \\
       f_{m-2} \\
       f_{m-1} \\
   \end{array} \right)
$$

<p>
The next step is  the backward substitution step.  The last row is multiplied by \( c_{N-3}/b_{N-2} \) and subtracted from the second to last row, thus eliminating \( c_{N-3} \) from the last row.  The general backward substitution procedure is 
$$
	c_i = 0, 
$$

and 
$$
	f_{i-1} = f_{i-1} - \frac{c_{i-1}}{b_i}f_i
$$

All that remains to be computed is the solution, which is the very straight forward process of
$$
x_i = \frac{f_i}{b_i}
$$

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>   Operation   </b></td> <td align="center"><b>Floating Point</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   Memory Reads       </td> <td align="center">   \( 14(N-2) \)     </td> </tr>
<tr><td align="center">   Memory Writes      </td> <td align="center">   \( 4(N-2) \)      </td> </tr>
<tr><td align="center">   Subtractions       </td> <td align="center">   \( 3(N-2) \)      </td> </tr>
<tr><td align="center">   Multiplications    </td> <td align="center">   \( 3(N-2) \)      </td> </tr>
<tr><td align="center">   Divisions          </td> <td align="center">   \( 4(N-2) \)      </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// Forward substitution    </span>
<span style="color: #408080; font-style: italic">// Note that we can simplify by precalculating a[i-1]/b[i-1]</span>
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i<span style="color: #666666">=1</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) {
     b[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">-</span> (a[i<span style="color: #666666">-1</span>]<span style="color: #666666">*</span>c[i<span style="color: #666666">-1</span>])<span style="color: #666666">/</span>b[i<span style="color: #666666">-1</span>];
     f[i] <span style="color: #666666">=</span> g[i] <span style="color: #666666">-</span> (a[i<span style="color: #666666">-1</span>]<span style="color: #666666">*</span>f[i<span style="color: #666666">-1</span>])<span style="color: #666666">/</span>b[i<span style="color: #666666">-1</span>];
  }
  x[n<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> f[n<span style="color: #666666">-1</span>] <span style="color: #666666">/</span> b[n<span style="color: #666666">-1</span>];
  <span style="color: #408080; font-style: italic">// Backwards substitution                                                           </span>
  <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> n<span style="color: #666666">-2</span>; i <span style="color: #666666">&gt;=</span> <span style="color: #666666">0</span>; i<span style="color: #666666">--</span>) {
     f[i] <span style="color: #666666">=</span> f[i] <span style="color: #666666">-</span> c[i]<span style="color: #666666">*</span>f[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>b[i<span style="color: #666666">+1</span>];
     x[i] <span style="color: #666666">=</span> f[i]<span style="color: #666666">/</span>b[i];
  }
</pre></div>

<h2 id="___sec19" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Projects/2016/Project1/Examples/TridiagonalTiming.cpp" target="_self">The specialized Thomas algorithm (Project 1)</a>  </h2>

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  Operation  </b></td> <td align="center"><b>Floating Point</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   Memory Reads     </td> <td align="center">   \( 6(N-2) \)      </td> </tr>
<tr><td align="center">   Memory Writes    </td> <td align="center">   \( 2(N-2) \)      </td> </tr>
<tr><td align="center">   Additions        </td> <td align="center">   \( 2(N-2) \)      </td> </tr>
<tr><td align="center">   Divisions        </td> <td align="center">   \( 2(N-2) \)      </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>      <span style="color: #408080; font-style: italic">// Forward substitution cannot be vectorized</span>
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">2</span>; i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>) b[i] <span style="color: #666666">=</span> b[i] <span style="color: #666666">+</span> b[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>d[i<span style="color: #666666">-1</span>];
      <span style="color: #408080; font-style: italic">// Backward substitution  cannot be vectorized</span>
      solution[n<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> b[n<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>d[n<span style="color: #666666">-1</span>];
      <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i <span style="color: #666666">=</span> n<span style="color: #666666">-2</span>; i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>; i<span style="color: #666666">--</span>) solution[i] <span style="color: #666666">=</span> (b[i]<span style="color: #666666">+</span>solution[i<span style="color: #666666">+1</span>])<span style="color: #666666">/</span>d[i];
</pre></div>

<h2 id="___sec20" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program8.cpp" target="_self">Example: Transpose of a matrix</a> </h2>

<p>

<!-- code=text (!bc cppcode) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &quot;time.h&quot;

using namespace std; // note use of namespace
int main (int argc, char* argv[])
{
  // read in dimension of square matrix
  int n = atoi(argv[1]);
  double **A, **B;
  // Allocate space for the two matrices
  A = new double*[n]; B = new double*[n];
  for (int i = 0; i &lt; n; i++){
    A[i] = new double[n];
    B[i] = new double[n];
  }
  // Set up values for matrix A
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      A[i][j] =  cos(i*1.0)*sin(j*3.0);
    }
  }
  clock_t start, finish;
  start = clock();
  // Then compute the transpose
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      B[i][j]= A[j][i];
    }
  }

  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
  cout &lt;&lt; setiosflags(ios::showpoint | ios::uppercase);
  cout &lt;&lt; setprecision(10) &lt;&lt; setw(20) &lt;&lt; &quot;Time used  for setting up transpose of matrix=&quot; &lt;&lt; timeused  &lt;&lt; endl;

  // Free up space
  for (int i = 0; i &lt; n; i++){
    delete[] A[i];
    delete[] B[i];
  }
  delete[] A;
  delete[] B;
  return 0;
}
</pre></div>

<h2 id="___sec21" class="anchor"><a href="https://github.com/CompPhysics/ComputationalPhysicsMSU/blob/master/doc/Programs/LecturePrograms/programs/Classes/cpp/program9.cpp" target="_self">Matrix-matrix multiplication</a> </h2>
This the matrix-matrix multiplication code with plain c++ memory allocation. It computes at the end the Frobenius norm.

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &quot;time.h&quot;

using namespace std; // note use of namespace
int main (int argc, char* argv[])
{
  // read in dimension of square matrix
  int n = atoi(argv[1]);
  double s = 1.0/sqrt( (double) n);
  double **A, **B, **C;
  // Start timing
  clock_t start, finish;
  start = clock();
  // Allocate space for the two matrices
  A = new double*[n]; B = new double*[n]; C = new double*[n];
  for (int i = 0; i &lt; n; i++){
    A[i] = new double[n];
    B[i] = new double[n];
    C[i] = new double[n];
  }
  // Set up values for matrix A and B and zero matrix C
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      double angle = 2.0*M_PI*i*j/ (( double ) n);
      A[i][j] = s * ( sin ( angle ) + cos ( angle ) );
      B[j][i] =  A[i][j];
    }
  }
  // Then perform the matrix-matrix multiplication
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      double sum = 0.0;
       for (int k = 0; k &lt; n; k++) {
           sum += B[i][k]*A[k][j];
       }
       C[i][j] = sum;
    }
  }
  // Compute now the Frobenius norm
  double Fsum = 0.0;
  for (int i = 0; i &lt; n; i++){
    for (int j = 0; j &lt; n; j++) {
      Fsum += C[i][j]*C[i][j];
    }
  }
  Fsum = sqrt(Fsum);
  finish = clock();
  double timeused = (double) (finish - start)/(CLOCKS_PER_SEC );
  cout &lt;&lt; setiosflags(ios::showpoint | ios::uppercase);
  cout &lt;&lt; setprecision(10) &lt;&lt; setw(20) &lt;&lt; &quot;Time used  for matrix-matrix multiplication=&quot; &lt;&lt; timeused  &lt;&lt; endl;
  cout &lt;&lt; &quot;  Frobenius norm  = &quot; &lt;&lt; Fsum &lt;&lt; endl;
  // Free up space
  for (int i = 0; i &lt; n; i++){
    delete[] A[i];
    delete[] B[i];
    delete[] C[i];
  }
  delete[] A;
  delete[] B;
  delete[] C;
  return 0;
}
</pre></div>

<h2 id="___sec22" class="anchor">How do we define speedup? Simplest form </h2>

<ul>
<li> Speedup(code,sys,p) = \( T_b/T_p \)</li>
<li> Speedup measures the ratio of performance between two objects</li>
<li> Versions of same code, with different number of processors</li>
<li> Serial and vector versions</li>
<li> Try different programing languages, C++ and Fortran</li>
<li> Two algorithms computing the <b>same</b> result</li> 
</ul>

The key is choosing the correct baseline for comparison

<ul>
<li> For our serial vs. vectorization examples, using compiler-provided vectorization, the baseline is simple; the same code, with vectorization turned off</li>

<ul>
 <li> For parallel applications, this is much harder:</li>

<ul>
  <li> Choice of algorithm, decomposition, performance of baseline case etc.</li>
</ul>

</ul>

</ul>

<h2 id="___sec23" class="anchor">Object orientation </h2>

<p>
Why object orientation?

<ul>
  <li> Three main topics: objects, class hierarchies and polymorphism</li>
  <li> The aim here is to be to be able to write a more general code which can easily be tailored to new situations.</li>
  <li> <b>Polymorphism</b> is a term used in software development to describe a variety of techniques employed by programmers to create flexible and reusable software components. The term is Greek and it loosely translates to "many forms". Strategy: try to single out the variables needed to describe a given system and those needed to describe a given solver.</li> 
</ul>

<h2 id="___sec24" class="anchor">Object orientation </h2>

<p>
In programming languages, a polymorphic object is an entity, such as a variable or a procedure, that can hold or operate on values of differing types during the program's execution. Because a polymorphic object can operate on a variety of values and types, it can also be used in a variety of programs, sometimes with little or no change by the programmer. The idea of write once, run many, also known as code reusability, is an important characteristic to the programming paradigm known as Object-Oriented Programming (OOP).

<p>
OOP describes an approach to programming where a program is viewed as a collection of interacting, but mostly independent software components. These software components are known as objects in OOP and they are typically implemented in a programming language as an entity that encapsulates both data and procedures.

<h2 id="___sec25" class="anchor">Programming classes </h2>

<p>
In Fortran a vector or matrix start with \( 1 \), but it is easy
to change a vector so that it starts with zero or even a negative number.
If we have a double precision Fortran vector  which starts at \( -10 \) and ends at \( 10 \), we could declare it as
<code>REAL(KIND=8) ::  vector(-10:10)</code>. Similarly, if we want to start at zero and end at 10 we could write
<code>REAL(KIND=8) ::  vector(0:10)</code>.
We have also seen that Fortran  allows us to write a matrix addition \( \mathbf{A} = \mathbf{B}+\mathbf{C} \) as
<code>A = B + C</code>.  This means that we have overloaded the addition operator so that it translates this operation into
two loops and an addition of two matrix elements \( a_{ij} = b_{ij}+c_{ij} \).

<h2 id="___sec26" class="anchor">Programming classes </h2>

<p>
The way the matrix addition is written is very close to the way we express this relation mathematically. The benefit for the
programmer is that our code is easier to read. Furthermore, such a way of coding makes it  more likely  to spot eventual
errors as well.

<p>
In Ansi C and C++ arrays start by default from \( i=0 \).  Moreover, if we  wish to add two matrices we need to explicitely write out
the two loops as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>   <span style="color: #008000; font-weight: bold">for</span>(i<span style="color: #666666">=0</span> ; i <span style="color: #666666">&lt;</span> n ; i<span style="color: #666666">++</span>) {
      <span style="color: #008000; font-weight: bold">for</span>(j<span style="color: #666666">=0</span> ; j <span style="color: #666666">&lt;</span> n ; j<span style="color: #666666">++</span>) {
         a[i][j]<span style="color: #666666">=</span>b[i][j]<span style="color: #666666">+</span>c[i][j]
</pre></div>

<h2 id="___sec27" class="anchor">Programming classes </h2>

<p>
However,
the strength of C++ is the possibility
to define new data types, tailored to some particular problem.
Via new data types and overloading of operations such as addition and subtraction, we can easily define
sets of operations and data types which allow us to write a matrix addition in exactly the same
way as we would do in Fortran.  We could also change the way we declare a C++ matrix elements \( a_{ij} \), from  \( a[i][j] \)
to say \( a(i,j) \), as we would do in Fortran. Similarly, we could also change the default range from \( 0:n-1 \) to \( 1:n \).

<p>
To achieve this we need to introduce two important entities in C++ programming, classes and templates.

<h2 id="___sec28" class="anchor">Programming classes </h2>

<p>
The function and class declarations are fundamental concepts within C++.  Functions are abstractions
which encapsulate an algorithm or parts of it and perform specific tasks in a program.
We have already met several examples on how to use  functions.
Classes can be defined as abstractions which encapsulate
data and operations on these data.
The data can be very complex data structures  and the class can contain particular functions
which operate on these data. Classes allow therefore for a higher level of abstraction in computing.
The elements (or components) of the data
type are the class data members, and the procedures are the class
member functions.

<h2 id="___sec29" class="anchor">Programming classes </h2>

<p>
Classes are user-defined tools used to create multi-purpose software which can be reused by other classes or functions.
These user-defined data types contain data (variables) and
functions operating on the data.

<p>
A simple example is that of a point in two dimensions.
The data could be the \( x \) and \( y \) coordinates of a given  point. The functions
we define could be simple read and write functions or the possibility to compute the distance between two points.

<h2 id="___sec30" class="anchor">Programming classes </h2>

<p>
C++ has a class complex in its standard
template library (STL). The standard usage in a given function could then look like

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// Program to calculate addition and multiplication of two complex numbers</span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cmath&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;complex&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  complex<span style="color: #666666">&lt;</span><span style="color: #B00040">double</span><span style="color: #666666">&gt;</span> x(<span style="color: #666666">6.1</span>,<span style="color: #666666">8.2</span>), y(<span style="color: #666666">0.5</span>,<span style="color: #666666">1.3</span>);
  <span style="color: #408080; font-style: italic">// write out x+y</span>
  cout <span style="color: #666666">&lt;&lt;</span> x <span style="color: #666666">+</span> y <span style="color: #666666">&lt;&lt;</span> x<span style="color: #666666">*</span>y  <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
</pre></div>
<p>
where we add and multiply two complex numbers \( x=6.1+\imath 8.2 \) and \( y=0.5+\imath 1.3 \) with the obvious results
\( z=x+y=6.6+\imath 9.5 \) and \( z=x\cdot y= -7.61+\imath 12.03 \).

<h2 id="___sec31" class="anchor">Programming classes </h2>

<p>
We proceed by  splitting our task in three files.

<p>
We define first a header file complex.h  which contains the declarations of
the class. The header file contains the class declaration (data and
functions), declaration of stand-alone functions, and all inlined
functions, starting as follows

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#ifndef Complex_H</span>
<span style="color: #BC7A00">#define Complex_H</span>
<span style="color: #408080; font-style: italic">//   various include statements and definitions</span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;          // Standard ANSI-C++ include files</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;new&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">....</span><span style="color: #BC7A00"></span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Complex</span>
{...
definition of variables and their character
};
<span style="color: #408080; font-style: italic">//   declarations of various functions used by the class</span>
...
<span style="color: #BC7A00">#endif</span>
</pre></div>

<h2 id="___sec32" class="anchor">Programming classes </h2>

<p>
Next we provide a file complex.cpp where the code and algorithms of
different functions (except inlined functions) declared within the
class are written.  The files <code>complex.h</code> and <code>complex.cpp</code> are normally
placed in a directory with other classes and libraries we have
defined.

<p>
Finally, we discuss here an example of a main program which uses this
particular class.  An example of a program which uses our complex
class is given below. In particular we would like our class to perform
tasks like declaring complex variables, writing out the real and
imaginary part and performing algebraic operations such as adding or
multiplying two complex numbers.

<h2 id="___sec33" class="anchor">Programming classes </h2>

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;Complex.h&quot;</span><span style="color: #BC7A00"></span>
...  other include and declarations
<span style="color: #B00040">int</span> main ()
{
  Complex a(<span style="color: #666666">0.1</span>,<span style="color: #666666">1.3</span>);    <span style="color: #408080; font-style: italic">// we declare a complex variable a</span>
  Complex <span style="color: #0000FF">b</span>(<span style="color: #666666">3.0</span>), c(<span style="color: #666666">5.0</span>,<span style="color: #666666">-2.3</span>);  <span style="color: #408080; font-style: italic">// we declare  complex variables b and c</span>
  Complex d <span style="color: #666666">=</span> b;         <span style="color: #408080; font-style: italic">//  we declare  a new complex variable d</span>
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;d=&quot;</span> <span style="color: #666666">&lt;&lt;</span> d <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;, a=&quot;</span> <span style="color: #666666">&lt;&lt;</span> a <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;, b=&quot;</span> <span style="color: #666666">&lt;&lt;</span> b <span style="color: #666666">&lt;&lt;</span> endl;
  d <span style="color: #666666">=</span> a<span style="color: #666666">*</span>c <span style="color: #666666">+</span> b<span style="color: #666666">/</span>a;  <span style="color: #408080; font-style: italic">//   we add, multiply and divide two complex numbers</span>
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Re(d)=&quot;</span> <span style="color: #666666">&lt;&lt;</span> d.Re() <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;, Im(d)=&quot;</span> <span style="color: #666666">&lt;&lt;</span> d.Im() <span style="color: #666666">&lt;&lt;</span> endl;  <span style="color: #408080; font-style: italic">// write out of the real and imaginary parts</span>
</pre></div>

<h2 id="___sec34" class="anchor">Programming classes </h2>

<p>
We include the header file complex.h and define four different complex variables. These
are \( a=0.1+\imath 1.3 \), \( b=3.0+\imath 0 \) (note that if you don't define a value for the imaginary part  this is set to
zero), \( c=5.0-\imath 2.3 \) and \( d=b \).  Thereafter we have defined standard algebraic operations and the member functions
of the class which allows us to print out the real and imaginary part of a given variable.

<h2 id="___sec35" class="anchor">Programming classes </h2>

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Complex</span>
{
<span style="color: #008000; font-weight: bold">private</span><span style="color: #666666">:</span>
   <span style="color: #B00040">double</span> re, im; <span style="color: #408080; font-style: italic">// real and imaginary part</span>
<span style="color: #008000; font-weight: bold">public</span><span style="color: #666666">:</span>
   Complex ();                              <span style="color: #408080; font-style: italic">// Complex c;</span>
   Complex (<span style="color: #B00040">double</span> re, <span style="color: #B00040">double</span> im <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>); <span style="color: #408080; font-style: italic">// Definition of a complex variable;</span>
   Complex (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c);              <span style="color: #408080; font-style: italic">// Usage: Complex c(a);   // equate two complex variables</span>
   Complex<span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c); <span style="color: #408080; font-style: italic">// c = a;   //  equate two complex variables, same as previous</span>
....
</pre></div>

<h2 id="___sec36" class="anchor">Programming classes </h2>

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #666666">~</span>Complex () {}                        <span style="color: #408080; font-style: italic">// destructor</span>
   <span style="color: #B00040">double</span>   Re () <span style="color: #008000; font-weight: bold">const</span>;        <span style="color: #408080; font-style: italic">// double real_part = a.Re();</span>
   <span style="color: #B00040">double</span>   <span style="color: #0000FF">Im</span> () <span style="color: #008000; font-weight: bold">const</span>;        <span style="color: #408080; font-style: italic">// double imag_part = a.Im();</span>
   <span style="color: #B00040">double</span>   <span style="color: #0000FF">abs</span> () <span style="color: #008000; font-weight: bold">const</span>;       <span style="color: #408080; font-style: italic">// double m = a.abs(); // modulus</span>
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">-</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">/</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
};
</pre></div>

<h2 id="___sec37" class="anchor">Programming classes </h2>

<p>
The class is defined via the statement <code>class Complex</code>. We must first use the key word
<code>class</code>, which in turn is followed by the user-defined variable name  <code>Complex</code>.
The body of the class, data and functions, is encapsulated  within the parentheses <code>{...}</code>.

<h2 id="___sec38" class="anchor">Programming classes </h2>

<p>
Data and specific functions can be private, which means that they cannot be accessed from outside the class.
This means also that access cannot be inherited by other functions outside the class. If we use <code>protected</code>
instead of <code>private</code>, then data and functions can be inherited outside the class.

<h2 id="___sec39" class="anchor">Programming classes </h2>

<p>
The key word <code>public</code> means  that data and functions can be accessed from outside the class.
Here we have defined several functions  which can be accessed by functions outside the class.
The declaration <code>friend</code> means that stand-alone functions can work on privately declared  variables  of the type
<code>(re, im)</code>.  Data members of a class should be declared as private variables.

<h2 id="___sec40" class="anchor">Programming classes </h2>

<p>
The first public function we encounter is a so-called
constructor, which  tells how we declare a variable of type <code>Complex</code>
and how this variable is initialized. We have chose  three possibilities in the example above:

<p>
A declaration like <code>Complex c;</code> calls the member function <code>Complex()</code> which can have the following implementation

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Complex<span style="color: #666666">::</span> Complex () { re <span style="color: #666666">=</span> im <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>; }
</pre></div>
<p>
meaning that it sets the real and imaginary parts to zero. Note the
way a member function is defined. The constructor is the first
function that is called when an object is instantiated.

<h2 id="___sec41" class="anchor">Programming classes </h2>

<p>
Another possibility is

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Complex<span style="color: #666666">::</span> Complex () {}
</pre></div>
<p>
which means that there is no initialization of the real and imaginary parts. The drawback is that a given compiler can then assign random values to a given variable.

<p>
A call like <code>Complex a(0.1,1.3);</code> means that we could call the member function `Complex(double, double)`as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Complex<span style="color: #666666">::</span> Complex (<span style="color: #B00040">double</span> re_a, <span style="color: #B00040">double</span> im_a) {
    re <span style="color: #666666">=</span> re_a; im <span style="color: #666666">=</span> im_a; }
</pre></div>

<h2 id="___sec42" class="anchor">Programming classes </h2>

<p>
The simplest member function are those we defined to extract
the real and imaginary part of a variable. Here you have to recall that these are private data,
that is they invisible for users of the class.  We obtain a copy of these variables by defining the
functions

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #B00040">double</span> Complex<span style="color: #666666">::</span> Re () <span style="color: #008000; font-weight: bold">const</span> { <span style="color: #008000; font-weight: bold">return</span> re; }} <span style="color: #408080; font-style: italic">//  getting the real part</span>
<span style="color: #B00040">double</span> Complex<span style="color: #666666">::</span> Im () <span style="color: #008000; font-weight: bold">const</span> { <span style="color: #008000; font-weight: bold">return</span> im; }  <span style="color: #408080; font-style: italic">//   and the imaginary part</span>
</pre></div>
<p>
Note that we have introduced   the declaration  <code>const</code>.  What does it mean?
This declaration means that a variabale cannot be changed within  a called function.

<h2 id="___sec43" class="anchor">Programming classes </h2>

<p>
If we define a variable as
<code>const double p = 3;</code> and then try to change its value, we will get an error when we
compile our program. This means that constant arguments in functions cannot be changed.

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// const arguments (in functions) cannot be changed:</span>
<span style="color: #B00040">void</span> <span style="color: #0000FF">myfunc</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{ c.re <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>; <span style="color: #408080; font-style: italic">/* ILLEGAL!! compiler error... */</span>  }
</pre></div>
<p>
If we declare the function and try to change the value to \( 0.2 \), the compiler will complain by sending
an error message.

<h2 id="___sec44" class="anchor">Programming classes </h2>

<p>
If we define a function to compute the absolute value of complex variable like

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #B00040">double</span> Complex<span style="color: #666666">::</span> abs ()  { <span style="color: #008000; font-weight: bold">return</span> sqrt(re<span style="color: #666666">*</span>re <span style="color: #666666">+</span> im<span style="color: #666666">*</span>im);}
</pre></div>
<p>
without the constant declaration  and define thereafter a function
<code>myabs</code> as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #B00040">double</span> <span style="color: #0000FF">myabs</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{ <span style="color: #008000; font-weight: bold">return</span> c.abs(); }   <span style="color: #408080; font-style: italic">// Not ok because c.abs() is not a const func.</span>
</pre></div>
<p>
the compiler would not allow the c.abs() call in myabs
since <code>Complex::abs</code> is not a constant member function.

<h2 id="___sec45" class="anchor">Programming classes </h2>

<p>
Constant functions cannot change the object's state.
To avoid this we declare the function <code>abs</code> as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #B00040">double</span> Complex<span style="color: #666666">::</span> abs () <span style="color: #008000; font-weight: bold">const</span> { <span style="color: #008000; font-weight: bold">return</span> sqrt(re<span style="color: #666666">*</span>re <span style="color: #666666">+</span> im<span style="color: #666666">*</span>im); }
</pre></div>

<h2 id="___sec46" class="anchor">Programming classes </h2>

<p>
C++ (and Fortran) allow for overloading of operators. That means we
can define algebraic operations on for example vectors or any
arbitrary object.  As an example, a vector addition of the type 
\( \mathbf{c} = \mathbf{a} + \mathbf{b} \) means that we need to write a small part of
code with a for-loop over the dimension of the array.  We would rather
like to write this statement as <code>c = a+b;</code> as this makes the code much
more readable and close to eventual equations we want to code.  To
achieve this we need to extend the definition of operators.

<h2 id="___sec47" class="anchor">Programming classes </h2>

<p>
Let us study the declarations in our complex class.
In our main function we have a statement like <code>d = b;</code>, which means
that we call <code>d.operator= (b)</code> and we have defined a so-called assignment operator
as a part of the class defined as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Complex<span style="color: #666666">&amp;</span> Complex<span style="color: #666666">::</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{
   re <span style="color: #666666">=</span> c.re;
   im <span style="color: #666666">=</span> c.im;
   <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">this</span>;
}
</pre></div>

<h2 id="___sec48" class="anchor">Programming classes </h2>

<p>
With this function, statements like
<code>Complex d = b;</code> or <code>Complex d(b);</code>
make a new object \( d \), which becomes a copy of \( b \).
We can make simple implementations in terms of the assignment

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Complex<span style="color: #666666">::</span> Complex (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{ <span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">this</span> <span style="color: #666666">=</span> c; }
</pre></div>
<p>
which  is a pointer to "this object", <code>*this</code> is the present object,
so <code>*this = c;</code> means setting the present object equal to \( c \), that is
<code>this-&gt;operator= (c);</code>.

<h2 id="___sec49" class="anchor">Programming classes </h2>

<p>
The meaning of the addition operator \( + \) for Complex objects is defined in the
function
<code>Complex operator+ (const Complex& a, const Complex& b); // a+b</code>
The compiler translates <code>c = a + b;</code> into <code>c = operator+ (a, b);</code>.
Since this implies the call to function, it brings in an additional overhead. If speed
is crucial and this function call is performed inside a loop, then it is more difficult for a
given compiler to perform optimizations of a loop.

<h2 id="___sec50" class="anchor">Programming classes </h2>

<p>
The solution to this is to inline functions.   We discussed inlining in chapter
2 of the lecture notes.
Inlining means that the function body is copied directly into
the calling code, thus avoiding calling the function.
Inlining is enabled by the inline keyword

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">inline</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b)
{ <span style="color: #008000; font-weight: bold">return</span> Complex (a.re <span style="color: #666666">+</span> b.re, a.im <span style="color: #666666">+</span> b.im); }
</pre></div>
<p>
Inline functions, with complete bodies must be written in the header file  complex.h.

<h2 id="___sec51" class="anchor">Programming classes </h2>

<p>
Consider  the case <code>c = a + b;</code>
that is,  <code>c.operator= (operator+ (a,b));</code>
If <code>operator+</code>, <code>operator=</code> and the constructor <code>Complex(r,i)</code> all
are inline functions, this transforms to

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>c.re <span style="color: #666666">=</span> a.re <span style="color: #666666">+</span> b.re;
c.im <span style="color: #666666">=</span> a.im <span style="color: #666666">+</span> b.im;
</pre></div>
<p>
by the compiler, i.e., no function calls

<h2 id="___sec52" class="anchor">Programming classes </h2>

<p>
The stand-alone function <code>operator+</code> is a friend of the Complex  class

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Complex</span>
{
   ...
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   ...
};
</pre></div>
<p>
so it can read (and manipulate) the private data parts \( re \) and
\( im \) via

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">inline</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b)
{ <span style="color: #008000; font-weight: bold">return</span> Complex (a.re <span style="color: #666666">+</span> b.re, a.im <span style="color: #666666">+</span> b.im); }
</pre></div>

<h2 id="___sec53" class="anchor">Programming classes </h2>

<p>
Since we do not need to alter the re and im variables, we can
get the values by Re() and Im(), and there is no need to be a
friend function

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">inline</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b)
{ <span style="color: #008000; font-weight: bold">return</span> Complex (a.Re() <span style="color: #666666">+</span> b.Re(), a.Im() <span style="color: #666666">+</span> b.Im()); }
</pre></div>

<h2 id="___sec54" class="anchor">Programming classes </h2>

<p>
The multiplication functionality can now be extended to imaginary numbers by the following code

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">inline</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b)
{
  <span style="color: #008000; font-weight: bold">return</span> Complex(a.re<span style="color: #666666">*</span>b.re <span style="color: #666666">-</span> a.im<span style="color: #666666">*</span>b.im, a.im<span style="color: #666666">*</span>b.re <span style="color: #666666">+</span> a.re<span style="color: #666666">*</span>b.im);
</pre></div>
<p>
It will be convenient to inline all functions used by this operator.

<h2 id="___sec55" class="anchor">Programming classes </h2>

<p>
To inline the complete expression <code>a*b;</code>, the constructors and
<code>operator=</code>  must also be inlined.  This can be achieved via the following piece of code

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">inline</span> Complex<span style="color: #666666">::</span> Complex () { re <span style="color: #666666">=</span> im <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>; }
<span style="color: #008000; font-weight: bold">inline</span> Complex<span style="color: #666666">::</span> Complex (<span style="color: #B00040">double</span> re_, <span style="color: #B00040">double</span> im_)
{ ... }
<span style="color: #008000; font-weight: bold">inline</span> Complex<span style="color: #666666">::</span> Complex (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{ ... }
<span style="color: #008000; font-weight: bold">inline</span> Complex<span style="color: #666666">::</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{ ... }
</pre></div>

<h2 id="___sec56" class="anchor">Programming classes </h2>

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// e, c, d are complex</span>
e <span style="color: #666666">=</span> c<span style="color: #666666">*</span>d;
<span style="color: #408080; font-style: italic">// first compiler translation:</span>
e.<span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span> (<span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span> (c,d));
<span style="color: #408080; font-style: italic">// result of nested inline functions</span>
<span style="color: #408080; font-style: italic">// operator=, operator*, Complex(double,double=0):</span>
e.re <span style="color: #666666">=</span> c.re<span style="color: #666666">*</span>d.re <span style="color: #666666">-</span> c.im<span style="color: #666666">*</span>d.im;
e.im <span style="color: #666666">=</span> c.im<span style="color: #666666">*</span>d.re <span style="color: #666666">+</span> c.re<span style="color: #666666">*</span>d.im;
</pre></div>
<p>
The definitions <code>operator-</code> and <code>operator/</code> follow the same set up.

<h2 id="___sec57" class="anchor">Programming classes </h2>

<p>
Finally, if we wish to write to file or another device a complex number using the simple syntax
<code>cout &lt;&lt; c;</code>, we obtain this by defining
the effect of \( < < \) for a Complex object as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>ostream<span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">&lt;&lt;</span> (ostream<span style="color: #666666">&amp;</span> o, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c)
{ o <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;(&quot;</span> <span style="color: #666666">&lt;&lt;</span> c.Re() <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> c.Im() <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;) &quot;</span>; <span style="color: #008000; font-weight: bold">return</span> o;}
</pre></div>

<h2 id="___sec58" class="anchor">Programming classes, templates </h2>

<p>
What if we wanted to make a class which takes integers
or floating point numbers with single precision?
A simple way to achieve this is copy and paste our class and replace <code>double</code> with for
example <code>int</code>.

<p>
C++  allows us to do this automatically via the usage of templates, which
are the C++ constructs for parameterizing parts of
classes. Class templates  is a template for producing classes. The declaration consists
of the keyword <code>template</code> followed by a list of template arguments enclosed in brackets.

<h2 id="___sec59" class="anchor">Programming classes </h2>

<p>
We can therefore make a more general class by rewriting our original example as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">template</span><span style="color: #666666">&lt;</span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">T</span><span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Complex</span>
{
<span style="color: #008000; font-weight: bold">private</span><span style="color: #666666">:</span>
   T re, im; <span style="color: #408080; font-style: italic">// real and imaginary part</span>
<span style="color: #008000; font-weight: bold">public</span><span style="color: #666666">:</span>
   Complex ();                              <span style="color: #408080; font-style: italic">// Complex c;</span>
   Complex (T re, T im <span style="color: #666666">=</span> <span style="color: #666666">0</span>); <span style="color: #408080; font-style: italic">// Definition of a complex variable;</span>
   Complex (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c);              <span style="color: #408080; font-style: italic">// Usage: Complex c(a);   // equate two complex variables</span>
   Complex<span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> c); <span style="color: #408080; font-style: italic">// c = a;   //  equate two complex variables, same as previous</span>
</pre></div>

<h2 id="___sec60" class="anchor">Programming classes </h2>

<p>
We can therefore make a more general class by rewriting our original example as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #666666">~</span>Complex () {}                        <span style="color: #408080; font-style: italic">// destructor</span>
   T   Re () <span style="color: #008000; font-weight: bold">const</span>;        <span style="color: #408080; font-style: italic">// T real_part = a.Re();</span>
   T   <span style="color: #0000FF">Im</span> () <span style="color: #008000; font-weight: bold">const</span>;        <span style="color: #408080; font-style: italic">// T imag_part = a.Im();</span>
   T   <span style="color: #0000FF">abs</span> () <span style="color: #008000; font-weight: bold">const</span>;       <span style="color: #408080; font-style: italic">// T m = a.abs(); // modulus</span>
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">-</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
   <span style="color: #008000; font-weight: bold">friend</span> Complex <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">/</span> (<span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span>  a, <span style="color: #008000; font-weight: bold">const</span> Complex<span style="color: #666666">&amp;</span> b);
};
</pre></div>

<h2 id="___sec61" class="anchor">Programming classes </h2>

<p>
What it says is that <code>Complex</code> is a parameterized type with \( T \) as a parameter and \( T \) has to be a type such as double
or float.
The class complex is now a class template
and we would define variables in a code as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Complex<span style="color: #666666">&lt;</span><span style="color: #B00040">double</span><span style="color: #666666">&gt;</span> a(<span style="color: #666666">10.0</span>,<span style="color: #666666">5.1</span>);
Complex<span style="color: #666666">&lt;</span><span style="color: #B00040">int</span><span style="color: #666666">&gt;</span> b(<span style="color: #666666">1</span>,<span style="color: #666666">0</span>);
</pre></div>

<h2 id="___sec62" class="anchor">Programming classes </h2>

<p>
Member functions of our class are defined by preceding the name of the function with the <code>template</code> keyword.
Consider the function we defined as <code>Complex:: Complex (double re_a, double im_a)</code>.
We would rewrite this function as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">template</span><span style="color: #666666">&lt;</span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">T</span><span style="color: #666666">&gt;</span>
Complex<span style="color: #666666">&lt;</span>T<span style="color: #666666">&gt;::</span> Complex (T re_a, T im_a)
{ re <span style="color: #666666">=</span> re_a; im <span style="color: #666666">=</span> im_a; }
</pre></div>
<p>
The member functions  are otherwise defined following ordinary member function definitions.

<h2 id="___sec63" class="anchor">Programming classes </h2>

<p>
Here follows a very simple first class in the file squared.h

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">// Not all declarations here</span>
<span style="color: #408080; font-style: italic">// Class to compute the square of a number</span>
<span style="color: #008000; font-weight: bold">template</span><span style="color: #666666">&lt;</span><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">T</span><span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Squared</span>{
  <span style="color: #008000; font-weight: bold">public</span><span style="color: #666666">:</span>
    <span style="color: #408080; font-style: italic">// Default constructor, not used here</span>
    Squared(){}

    <span style="color: #408080; font-style: italic">// Overload the function operator()</span>
    T <span style="color: #008000; font-weight: bold">operator</span>()(T x){<span style="color: #008000; font-weight: bold">return</span> x<span style="color: #666666">*</span>x;}

};
</pre></div>

<h2 id="___sec64" class="anchor">Programming classes </h2>

<p>
and we would use it as

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;squared.h&quot;</span><span style="color: #BC7A00"></span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>(){
  Squared<span style="color: #666666">&lt;</span><span style="color: #B00040">double</span><span style="color: #666666">&gt;</span> s;
  cout <span style="color: #666666">&lt;&lt;</span> s(<span style="color: #666666">3</span>) <span style="color: #666666">&lt;&lt;</span> endl;
</pre></div>

<h2 id="___sec65" class="anchor">A matrix-vector class, first its usage </h2>
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cmath&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;fstream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iomanip&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;/Users/hjensen/Teaching/fys4411/programs/cgm/vectorclass.h&quot;</span><span style="color: #BC7A00"></span>

<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span>  std;

  Vector <span style="color: #0000FF">ConjugateGradient</span>(Matrix A, Vector b, Vector x0){
  <span style="color: #B00040">int</span> dim <span style="color: #666666">=</span> x0.Dimension();
  <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> tolerance <span style="color: #666666">=</span> <span style="color: #666666">1.0e-14</span>;
  Vector x(dim),r(dim),v(dim),z(dim);
  <span style="color: #B00040">double</span> c,t,d;

  x <span style="color: #666666">=</span> x0;
  r <span style="color: #666666">=</span> b <span style="color: #666666">-</span> A<span style="color: #666666">*</span>x;
  v <span style="color: #666666">=</span> r;
  c <span style="color: #666666">=</span> dot(r,r);
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dim;i<span style="color: #666666">++</span>){
    <span style="color: #008000; font-weight: bold">if</span>(sqrt(dot(v,v))<span style="color: #666666">&lt;</span>tolerance){
      cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;An error has occurred in ConjugateGradient: execution of function terminated&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
      <span style="color: #008000; font-weight: bold">break</span>;
    }
    z <span style="color: #666666">=</span> A<span style="color: #666666">*</span>v;
    t <span style="color: #666666">=</span> c<span style="color: #666666">/</span>dot(v,z);
    x <span style="color: #666666">=</span> x <span style="color: #666666">+</span> t<span style="color: #666666">*</span>v;
    r <span style="color: #666666">=</span> r <span style="color: #666666">-</span> t<span style="color: #666666">*</span>z;
    d <span style="color: #666666">=</span> dot(r,r);
    <span style="color: #008000; font-weight: bold">if</span>(sqrt(d) <span style="color: #666666">&lt;</span> tolerance)
      <span style="color: #008000; font-weight: bold">break</span>;
    v <span style="color: #666666">=</span> r <span style="color: #666666">+</span> (d<span style="color: #666666">/</span>c)<span style="color: #666666">*</span>v;
    c <span style="color: #666666">=</span> d;
  }
  <span style="color: #008000; font-weight: bold">return</span> x;
}


Vector <span style="color: #0000FF">SteepestDescent</span>(Matrix A, Vector b, Vector x0){
  <span style="color: #B00040">int</span> IterMax, i;
  <span style="color: #B00040">int</span> dim <span style="color: #666666">=</span> x0.Dimension();
  <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> tolerance <span style="color: #666666">=</span> <span style="color: #666666">1.0e-14</span>;
  Vector x(dim),f(dim),z(dim);
  <span style="color: #B00040">double</span> c,alpha,d;
  IterMax <span style="color: #666666">=</span> <span style="color: #666666">30</span>;
  x <span style="color: #666666">=</span> x0;
  f <span style="color: #666666">=</span> A<span style="color: #666666">*</span>x<span style="color: #666666">-</span>b;
  i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #008000; font-weight: bold">while</span> (i <span style="color: #666666">&lt;=</span> IterMax <span style="color: #666666">||</span> sqrt(dot(f,f)) <span style="color: #666666">&lt;</span> tolerance ){
    <span style="color: #008000; font-weight: bold">if</span>(sqrt(dot(f,f))<span style="color: #666666">&lt;</span>tolerance){
       cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;An error has occurred: execution of function terminated&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
       <span style="color: #008000; font-weight: bold">break</span>;
    }
    z <span style="color: #666666">=</span> A<span style="color: #666666">*</span>f;
    c <span style="color: #666666">=</span> dot(f,f);
    alpha <span style="color: #666666">=</span> c<span style="color: #666666">/</span>dot(f,z);
    x <span style="color: #666666">=</span> x <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>f;
    f <span style="color: #666666">=</span>  A<span style="color: #666666">*</span>x<span style="color: #666666">-</span>b;
    <span style="color: #008000; font-weight: bold">if</span>(sqrt(dot(f,f)) <span style="color: #666666">&lt;</span> tolerance) <span style="color: #008000; font-weight: bold">break</span>;
    i<span style="color: #666666">++</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> x;
}

<span style="color: #408080; font-style: italic">//   Main function begins here</span>
<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>(<span style="color: #B00040">int</span>  argc, <span style="color: #B00040">char</span> <span style="color: #666666">*</span> argv[]){
  <span style="color: #B00040">int</span> dim <span style="color: #666666">=</span> <span style="color: #666666">2</span>;
  Vector x(dim),xsd(dim), b(dim),x0(dim);
  Matrix A(dim,dim);

  <span style="color: #408080; font-style: italic">// Set our initial guess</span>
  x0(<span style="color: #666666">0</span>) <span style="color: #666666">=</span> x0(<span style="color: #666666">1</span>) <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #408080; font-style: italic">// Set the matrix</span>
  A(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>) <span style="color: #666666">=</span>  <span style="color: #666666">3</span>;    A(<span style="color: #666666">1</span>,<span style="color: #666666">0</span>) <span style="color: #666666">=</span>  <span style="color: #666666">2</span>;   A(<span style="color: #666666">0</span>,<span style="color: #666666">1</span>) <span style="color: #666666">=</span>  <span style="color: #666666">2</span>;   A(<span style="color: #666666">1</span>,<span style="color: #666666">1</span>) <span style="color: #666666">=</span>  <span style="color: #666666">6</span>;

  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;The Matrix A that we are using: &quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
  A.Print();
  cout <span style="color: #666666">&lt;&lt;</span> endl;

  Vector y(dim);
  y(<span style="color: #666666">0</span>) <span style="color: #666666">=</span> <span style="color: #666666">2.</span>;
  y(<span style="color: #666666">1</span>) <span style="color: #666666">=</span> <span style="color: #666666">-2.</span>;

  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;The exact solution is: &quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
  y.Print();
  cout <span style="color: #666666">&lt;&lt;</span> endl;
  b <span style="color: #666666">=</span> A<span style="color: #666666">*</span>y;

  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;The right hand side, b, of the expression Ax=b: &quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
  b.Print();
  cout <span style="color: #666666">&lt;&lt;</span> endl;

  x <span style="color: #666666">=</span> ConjugateGradient(A,b,x0);

  xsd <span style="color: #666666">=</span> SteepestDescent(A,b,x0);

  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;The approximate solution using Conjugate Gradient is: &quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
  x.Print();
  cout <span style="color: #666666">&lt;&lt;</span> endl;

  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;The approximate solution using Steepest Descent is: &quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
  xsd.Print();
  cout <span style="color: #666666">&lt;&lt;</span> endl;
}
</pre></div>

<h2 id="___sec66" class="anchor">A matrix-vector class, the class definitions themselves </h2>

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#ifndef _vectorclass</span>
<span style="color: #BC7A00">#define _vectorclass</span>


<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;cmath&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span>  std;



<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Point</span>;
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Vector</span>;
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Matrix</span>;


<span style="color: #408080; font-style: italic">/********************************/</span>
<span style="color: #408080; font-style: italic">/*        Point Class        */</span>
<span style="color: #408080; font-style: italic">/********************************/</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Point</span>{
 <span style="color: #008000; font-weight: bold">private</span><span style="color: #666666">:</span>
  <span style="color: #B00040">int</span>   dimension;
  <span style="color: #B00040">double</span> <span style="color: #666666">*</span>data;
  
 <span style="color: #008000; font-weight: bold">public</span><span style="color: #666666">:</span>
  Point(<span style="color: #B00040">int</span> dim);
  Point(<span style="color: #008000; font-weight: bold">const</span> Point<span style="color: #666666">&amp;</span> v);
  <span style="color: #666666">~</span>Point();
  
  <span style="color: #B00040">int</span>    <span style="color: #0000FF">Dimension</span>() <span style="color: #008000; font-weight: bold">const</span>;

  <span style="color: #408080; font-style: italic">//************************</span>
  <span style="color: #408080; font-style: italic">// User Defined Operators</span>
  <span style="color: #408080; font-style: italic">//************************</span>
  <span style="color: #B00040">int</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">==</span>(<span style="color: #008000; font-weight: bold">const</span> Point<span style="color: #666666">&amp;</span> v) <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">int</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">!=</span>(<span style="color: #008000; font-weight: bold">const</span> Point<span style="color: #666666">&amp;</span> v) <span style="color: #008000; font-weight: bold">const</span>;
  Point <span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(<span style="color: #008000; font-weight: bold">const</span> Point<span style="color: #666666">&amp;</span> v);

  <span style="color: #B00040">double</span>  <span style="color: #0000FF">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i) <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">double</span><span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i);

  <span style="color: #B00040">void</span> <span style="color: #0000FF">Print</span>() <span style="color: #008000; font-weight: bold">const</span>;
};



<span style="color: #408080; font-style: italic">/********************************/</span>
<span style="color: #408080; font-style: italic">/*        Vector Class        */</span>
<span style="color: #408080; font-style: italic">/********************************/</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Vector</span>{
 <span style="color: #008000; font-weight: bold">private</span><span style="color: #666666">:</span>
  <span style="color: #B00040">int</span>   dimension;
  <span style="color: #B00040">double</span> <span style="color: #666666">*</span>data;
  
 <span style="color: #008000; font-weight: bold">public</span><span style="color: #666666">:</span>
  Vector();
  Vector(<span style="color: #B00040">int</span> dim);
  Vector(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v);
  Vector(<span style="color: #B00040">int</span> col, <span style="color: #008000; font-weight: bold">const</span> Matrix <span style="color: #666666">&amp;</span>A);
  <span style="color: #666666">~</span>Vector();
  
  <span style="color: #B00040">void</span> <span style="color: #0000FF">Initialize</span>(<span style="color: #B00040">int</span> dim);
  <span style="color: #B00040">int</span>    <span style="color: #0000FF">Dimension</span>() <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">double</span> <span style="color: #0000FF">Length</span>();     <span style="color: #408080; font-style: italic">/* Euclidean Norm of the Vector */</span>
  <span style="color: #B00040">void</span>   <span style="color: #0000FF">Normalize</span>();

  <span style="color: #B00040">double</span> <span style="color: #0000FF">Norm_l1</span>();
  <span style="color: #B00040">double</span> <span style="color: #0000FF">Norm_l2</span>();
  <span style="color: #B00040">double</span> <span style="color: #0000FF">Norm_linf</span>();
  <span style="color: #B00040">double</span> <span style="color: #0000FF">MaxMod</span>();
  <span style="color: #B00040">double</span> <span style="color: #0000FF">ElementofMaxMod</span>();
  <span style="color: #B00040">int</span> <span style="color: #0000FF">MaxModindex</span>();
  
  <span style="color: #408080; font-style: italic">//************************</span>
  <span style="color: #408080; font-style: italic">// User Defined Operators</span>
  <span style="color: #408080; font-style: italic">//************************</span>
  <span style="color: #B00040">int</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">==</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v) <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">int</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">!=</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v) <span style="color: #008000; font-weight: bold">const</span>;
  Vector <span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v);

  <span style="color: #B00040">double</span>  <span style="color: #0000FF">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i) <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">double</span><span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i);

  <span style="color: #B00040">void</span> <span style="color: #0000FF">Print</span>() <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">void</span> <span style="color: #0000FF">Initialize</span>(<span style="color: #B00040">double</span> a);
  <span style="color: #B00040">void</span> <span style="color: #0000FF">Initialize</span>(<span style="color: #B00040">double</span> <span style="color: #666666">*</span>v);
};



<span style="color: #408080; font-style: italic">/********************************/</span>
<span style="color: #408080; font-style: italic">/*        Matrix Class        */</span>
<span style="color: #408080; font-style: italic">/********************************/</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Matrix</span> {
<span style="color: #008000; font-weight: bold">private</span><span style="color: #666666">:</span>
  <span style="color: #B00040">int</span> rows, columns;
  <span style="color: #B00040">double</span> <span style="color: #666666">**</span>data;
  
<span style="color: #008000; font-weight: bold">public</span><span style="color: #666666">:</span>

  Matrix(<span style="color: #B00040">int</span> dim);
  Matrix(<span style="color: #B00040">int</span> rows1, <span style="color: #B00040">int</span> columns1);
  Matrix(<span style="color: #008000; font-weight: bold">const</span> Matrix<span style="color: #666666">&amp;</span> m);
  Matrix(<span style="color: #B00040">int</span> num_vectors, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">*</span> q);
  Matrix(<span style="color: #B00040">int</span> rows1, <span style="color: #B00040">int</span> columns1, <span style="color: #B00040">double</span> <span style="color: #666666">**</span>rowptrs);
  <span style="color: #666666">~</span>Matrix();

  <span style="color: #B00040">int</span> <span style="color: #0000FF">Rows</span>() <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">int</span> <span style="color: #0000FF">Columns</span>() <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">double</span> <span style="color: #666666">**</span> <span style="color: #0000FF">GetPointer</span>();
  <span style="color: #B00040">void</span> <span style="color: #0000FF">GetColumn</span>(<span style="color: #B00040">int</span> col, Vector <span style="color: #666666">&amp;</span>x);
  <span style="color: #B00040">void</span> <span style="color: #0000FF">GetColumn</span>(<span style="color: #B00040">int</span> col, Vector <span style="color: #666666">&amp;</span>x, <span style="color: #B00040">int</span> rowoffset);
  <span style="color: #B00040">void</span> <span style="color: #0000FF">PutColumn</span>(<span style="color: #B00040">int</span> col, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>x);
  <span style="color: #B00040">double</span> <span style="color: #0000FF">Norm_l1</span>();
  <span style="color: #B00040">double</span> <span style="color: #0000FF">Norm_linf</span>();

  <span style="color: #408080; font-style: italic">//************************</span>
  <span style="color: #408080; font-style: italic">// User Defined Operators</span>
  <span style="color: #408080; font-style: italic">//************************</span>
  Matrix<span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(<span style="color: #008000; font-weight: bold">const</span> Matrix<span style="color: #666666">&amp;</span> m);
  <span style="color: #B00040">double</span> <span style="color: #0000FF">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> j) <span style="color: #008000; font-weight: bold">const</span>;
  <span style="color: #B00040">double</span><span style="color: #666666">&amp;</span> <span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> j);

  <span style="color: #B00040">double</span> <span style="color: #0000FF">MaxModInRow</span>(<span style="color: #B00040">int</span> row);
  <span style="color: #B00040">double</span> <span style="color: #0000FF">MaxModInRow</span>(<span style="color: #B00040">int</span> row, <span style="color: #B00040">int</span> starting_column);
  <span style="color: #B00040">int</span> <span style="color: #0000FF">MaxModInRowindex</span>(<span style="color: #B00040">int</span> row);
  <span style="color: #B00040">int</span> <span style="color: #0000FF">MaxModInRowindex</span>(<span style="color: #B00040">int</span> row, <span style="color: #B00040">int</span> starting_column);
 
  <span style="color: #B00040">double</span> <span style="color: #0000FF">MaxModInColumn</span>(<span style="color: #B00040">int</span> column);
  <span style="color: #B00040">double</span> <span style="color: #0000FF">MaxModInColumn</span>(<span style="color: #B00040">int</span> column, <span style="color: #B00040">int</span> starting_row);
  <span style="color: #B00040">int</span> <span style="color: #0000FF">MaxModInColumnindex</span>(<span style="color: #B00040">int</span> column);
  <span style="color: #B00040">int</span> <span style="color: #0000FF">MaxModInColumnindex</span>(<span style="color: #B00040">int</span> column, <span style="color: #B00040">int</span> starting_row);

  <span style="color: #B00040">void</span> <span style="color: #0000FF">RowSwap</span>(<span style="color: #B00040">int</span> row1, <span style="color: #B00040">int</span> row2);

  <span style="color: #B00040">void</span> <span style="color: #0000FF">Print</span>() <span style="color: #008000; font-weight: bold">const</span>;

};


<span style="color: #408080; font-style: italic">/********************************/</span>
<span style="color: #408080; font-style: italic">/*   Operator Declarations      */</span>
<span style="color: #408080; font-style: italic">/********************************/</span>

<span style="color: #408080; font-style: italic">// Unitary operator -</span>
Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">-</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v);

<span style="color: #408080; font-style: italic">// Binary operator +,-</span>
Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v1, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v2);
Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">-</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v1, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v2);

<span style="color: #408080; font-style: italic">// Vector Scaling (multiplication by a scaler : defined commutatively)</span>
Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span>(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> s, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v);
Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> s);

<span style="color: #408080; font-style: italic">// Vector Scaling (division by a scaler)</span>
Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">/</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> s);

Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span>(<span style="color: #008000; font-weight: bold">const</span> Matrix<span style="color: #666666">&amp;</span> A, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> x); 


<span style="color: #408080; font-style: italic">/********************************/</span>
<span style="color: #408080; font-style: italic">/*   Function Declarations      */</span>
<span style="color: #408080; font-style: italic">/********************************/</span>

<span style="color: #B00040">int</span> <span style="color: #0000FF">min_dimension</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> u, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v);
<span style="color: #B00040">double</span> <span style="color: #0000FF">dot</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> u, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v); 
<span style="color: #B00040">double</span> <span style="color: #0000FF">dot</span>(<span style="color: #B00040">int</span> N, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>a, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>b);
<span style="color: #B00040">double</span> <span style="color: #0000FF">dot</span>(<span style="color: #B00040">int</span> N, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>u, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>v); 
<span style="color: #B00040">void</span> <span style="color: #0000FF">Swap</span>(<span style="color: #B00040">double</span> <span style="color: #666666">&amp;</span>a, <span style="color: #B00040">double</span> <span style="color: #666666">&amp;</span>b);
<span style="color: #B00040">double</span> <span style="color: #0000FF">Sign</span>(<span style="color: #B00040">double</span> x);

<span style="color: #408080; font-style: italic">/* Misc. useful functions to have */</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">log2</span>(<span style="color: #B00040">double</span> x);
<span style="color: #B00040">double</span> <span style="color: #0000FF">GammaF</span>(<span style="color: #B00040">double</span> x);
<span style="color: #B00040">int</span> <span style="color: #0000FF">Factorial</span>(<span style="color: #B00040">int</span> n);
<span style="color: #B00040">double</span> <span style="color: #666666">**</span> <span style="color: #0000FF">CreateMatrix</span>(<span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n);
<span style="color: #B00040">void</span> <span style="color: #0000FF">DestroyMatrix</span>(<span style="color: #B00040">double</span> <span style="color: #666666">**</span> mat, <span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n); 

<span style="color: #B00040">int</span> <span style="color: #666666">**</span> <span style="color: #0000FF">ICreateMatrix</span>(<span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n);
<span style="color: #B00040">void</span> <span style="color: #0000FF">IDestroyMatrix</span>(<span style="color: #B00040">int</span> <span style="color: #666666">**</span> mat, <span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n);

<span style="color: #BC7A00">#endif</span>
</pre></div>

<h2 id="___sec67" class="anchor">A matrix-vector class, and finally all its functions </h2>

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;vectorclass.h&quot;</span><span style="color: #BC7A00"></span>

Point<span style="color: #666666">::</span>Point(<span style="color: #B00040">int</span> dim){
  dimension <span style="color: #666666">=</span> dim;
  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[dimension];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
}


Point<span style="color: #666666">::</span>Point(<span style="color: #008000; font-weight: bold">const</span> Point <span style="color: #666666">&amp;</span>v){
  dimension <span style="color: #666666">=</span> v.Dimension();
  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[dimension];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> v.data[i];
}


Point<span style="color: #666666">::~</span>Point(){
  dimension <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #008000; font-weight: bold">delete</span>[] data;
  data <span style="color: #666666">=</span> <span style="color: #008000">NULL</span>;
}


<span style="color: #B00040">int</span> Point<span style="color: #666666">::</span>Dimension() <span style="color: #008000; font-weight: bold">const</span>{
  <span style="color: #008000; font-weight: bold">return</span>(dimension);
}


<span style="color: #B00040">double</span> Point<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i) <span style="color: #008000; font-weight: bold">const</span>{
  <span style="color: #008000; font-weight: bold">if</span>(i<span style="color: #666666">&gt;=0</span> <span style="color: #666666">&amp;&amp;</span> i<span style="color: #666666">&lt;</span>dimension)
    <span style="color: #008000; font-weight: bold">return</span> data[i];

  cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Point::Invalid index &quot;</span> <span style="color: #666666">&lt;&lt;</span> i <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; for Point of dimension &quot;</span> <span style="color: #666666">&lt;&lt;</span> dimension <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span>(<span style="color: #666666">0</span>);
}



<span style="color: #B00040">double</span><span style="color: #666666">&amp;</span> Point<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i){
  <span style="color: #008000; font-weight: bold">if</span>(i<span style="color: #666666">&gt;=0</span> <span style="color: #666666">&amp;&amp;</span> i<span style="color: #666666">&lt;</span>dimension)
    <span style="color: #008000; font-weight: bold">return</span> data[i];

  cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Point::Invalid index &quot;</span> <span style="color: #666666">&lt;&lt;</span> i <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; for Point of dimension &quot;</span> <span style="color: #666666">&lt;&lt;</span> dimension <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span>(data[<span style="color: #666666">0</span>]);
}


Point<span style="color: #666666">&amp;</span> Point<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(<span style="color: #008000; font-weight: bold">const</span> Point <span style="color: #666666">&amp;</span>v) {
  dimension <span style="color: #666666">=</span> v.Dimension();
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> v.data[i];
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">this</span>;
};

<span style="color: #B00040">void</span> Point<span style="color: #666666">::</span>Print() <span style="color: #008000; font-weight: bold">const</span>{
  cout <span style="color: #666666">&lt;&lt;</span> endl;
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;[ &quot;</span>;
  <span style="color: #008000; font-weight: bold">if</span>(dimension<span style="color: #666666">&gt;0</span>)
    cout <span style="color: #666666">&lt;&lt;</span> data[<span style="color: #666666">0</span>];
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=1</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;; &quot;</span> <span style="color: #666666">&lt;&lt;</span> data[i];
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; ]&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
}

Vector<span style="color: #666666">::</span>Vector(){
  dimension <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  data <span style="color: #666666">=</span> <span style="color: #008000">NULL</span>;
}


Vector<span style="color: #666666">::</span>Vector(<span style="color: #B00040">int</span> dim){
  dimension <span style="color: #666666">=</span> dim;
  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[dimension];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
}


Vector<span style="color: #666666">::</span>Vector(<span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>v){
  dimension <span style="color: #666666">=</span> v.Dimension();
  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[dimension];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> v.data[i];
}


Vector<span style="color: #666666">::</span>Vector(<span style="color: #B00040">int</span> col, <span style="color: #008000; font-weight: bold">const</span> Matrix <span style="color: #666666">&amp;</span>A){
  dimension <span style="color: #666666">=</span> A.Rows();

  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[dimension];
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>A.Rows();i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> A(i,col);

}


Vector<span style="color: #666666">::~</span>Vector(){
  dimension <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #008000; font-weight: bold">delete</span>[] data;
  data <span style="color: #666666">=</span> <span style="color: #008000">NULL</span>;
}


<span style="color: #B00040">void</span> Vector<span style="color: #666666">::</span>Initialize(<span style="color: #B00040">int</span> dim){
  <span style="color: #008000; font-weight: bold">if</span>(dimension<span style="color: #666666">!=0</span>)
    <span style="color: #008000; font-weight: bold">delete</span>[] data;

  dimension <span style="color: #666666">=</span> dim;
  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[dimension];
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
}


<span style="color: #B00040">int</span> Vector<span style="color: #666666">::</span>Dimension() <span style="color: #008000; font-weight: bold">const</span>{
  <span style="color: #008000; font-weight: bold">return</span>(dimension);
}


<span style="color: #B00040">double</span> Vector<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i) <span style="color: #008000; font-weight: bold">const</span>{
  <span style="color: #008000; font-weight: bold">if</span>(i<span style="color: #666666">&gt;=0</span> <span style="color: #666666">&amp;&amp;</span> i<span style="color: #666666">&lt;</span>dimension)
    <span style="color: #008000; font-weight: bold">return</span> data[i];

  cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Vector::Invalid index &quot;</span> <span style="color: #666666">&lt;&lt;</span> i <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; for Vector of dimension &quot;</span> <span style="color: #666666">&lt;&lt;</span> dimension <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span>(<span style="color: #666666">0</span>);
}



<span style="color: #B00040">double</span><span style="color: #666666">&amp;</span> Vector<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i){
  <span style="color: #008000; font-weight: bold">if</span>(i<span style="color: #666666">&gt;=0</span> <span style="color: #666666">&amp;&amp;</span> i<span style="color: #666666">&lt;</span>dimension)
    <span style="color: #008000; font-weight: bold">return</span> data[i];

  cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Vector::Invalid index &quot;</span> <span style="color: #666666">&lt;&lt;</span> i <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; for Vector of dimension &quot;</span> <span style="color: #666666">&lt;&lt;</span> dimension <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span>(data[<span style="color: #666666">0</span>]);
}


Vector<span style="color: #666666">&amp;</span> Vector<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(<span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>v) {
  dimension <span style="color: #666666">=</span> v.Dimension();
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> v.data[i];
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">this</span>;
};

<span style="color: #B00040">void</span> Vector<span style="color: #666666">::</span>Print() <span style="color: #008000; font-weight: bold">const</span>{
  cout <span style="color: #666666">&lt;&lt;</span> endl;
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;[ &quot;</span>;
  <span style="color: #008000; font-weight: bold">if</span>(dimension<span style="color: #666666">&gt;0</span>)
    cout <span style="color: #666666">&lt;&lt;</span> data[<span style="color: #666666">0</span>];
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=1</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;; &quot;</span> <span style="color: #666666">&lt;&lt;</span> data[i];
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; ]&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
}


<span style="color: #B00040">double</span> Vector<span style="color: #666666">::</span>Norm_l1(){
  <span style="color: #B00040">double</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    sum <span style="color: #666666">+=</span> fabs(data[i]);
  <span style="color: #008000; font-weight: bold">return</span>(sum);
}


<span style="color: #B00040">double</span> Vector<span style="color: #666666">::</span>Norm_l2(){
  <span style="color: #B00040">double</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    sum <span style="color: #666666">+=</span> data[i]<span style="color: #666666">*</span>data[i];
  <span style="color: #008000; font-weight: bold">return</span>(sqrt(sum));
}

<span style="color: #B00040">void</span> Vector<span style="color: #666666">::</span>Normalize(){
  <span style="color: #B00040">double</span> tmp <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>Norm_l2();
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> data[i]<span style="color: #666666">*</span>tmp;
}


<span style="color: #B00040">double</span> Vector<span style="color: #666666">::</span>Norm_linf(){
  <span style="color: #B00040">double</span> maxval <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>,tmp;
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>dimension;i<span style="color: #666666">++</span>){
    tmp <span style="color: #666666">=</span> fabs(data[i]);
    maxval <span style="color: #666666">=</span> (maxval <span style="color: #666666">&gt;</span> tmp)<span style="color: #666666">?</span><span style="color: #A0A000">maxval</span>:tmp;
  }
  <span style="color: #008000; font-weight: bold">return</span>(maxval);
}

<span style="color: #B00040">double</span> Vector<span style="color: #666666">::</span>MaxMod(){
  <span style="color: #B00040">double</span> maxm <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;</span>dimension; i<span style="color: #666666">++</span>)
    maxm <span style="color: #666666">=</span> (maxm <span style="color: #666666">&gt;</span> fabs(data[i]))<span style="color: #666666">?</span><span style="color: #A0A000">maxm</span>:fabs(data[i]);
  
  <span style="color: #008000; font-weight: bold">return</span> maxm;
}

<span style="color: #B00040">double</span> Vector<span style="color: #666666">::</span>ElementofMaxMod(){
  <span style="color: #008000; font-weight: bold">return</span>(data[MaxModindex()]);
}


<span style="color: #B00040">int</span> Vector<span style="color: #666666">::</span>MaxModindex(){
  <span style="color: #B00040">double</span> maxm <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  <span style="color: #B00040">int</span> maxmindex <span style="color: #666666">=</span> <span style="color: #666666">0</span>;

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;</span>dimension; i<span style="color: #666666">++</span>){
    <span style="color: #008000; font-weight: bold">if</span>(maxm<span style="color: #666666">&lt;</span>fabs(data[i])){
      maxm <span style="color: #666666">=</span> fabs(data[i]);
      maxmindex <span style="color: #666666">=</span> i;
    }
  }
  
  <span style="color: #008000; font-weight: bold">return</span> maxmindex;
}

<span style="color: #B00040">void</span> Vector<span style="color: #666666">::</span>Initialize(<span style="color: #B00040">double</span> a){
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;</span>dimension; i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> a;
}

<span style="color: #B00040">void</span> Vector<span style="color: #666666">::</span>Initialize(<span style="color: #B00040">double</span> <span style="color: #666666">*</span>v){
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;</span>dimension; i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> v[i];
}

Matrix<span style="color: #666666">::</span>Matrix(<span style="color: #B00040">int</span> dim){
  rows <span style="color: #666666">=</span> dim;
  columns <span style="color: #666666">=</span> dim;
  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span><span style="color: #666666">*</span>[rows];
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    data[i] <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[columns];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>)
      data[i][j] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  }
}

  
Matrix<span style="color: #666666">::</span>Matrix(<span style="color: #B00040">int</span> rows1, <span style="color: #B00040">int</span> columns1){
  rows <span style="color: #666666">=</span> rows1;
  columns <span style="color: #666666">=</span> columns1;

  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span><span style="color: #666666">*</span>[rows];
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    data[i] <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[columns];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>)
      data[i][j] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  }
}

Matrix<span style="color: #666666">::</span>Matrix(<span style="color: #008000; font-weight: bold">const</span> Matrix<span style="color: #666666">&amp;</span> m){
  rows <span style="color: #666666">=</span> m.rows;
  columns <span style="color: #666666">=</span> m.columns;

  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span><span style="color: #666666">*</span>[rows];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    data[i] <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[columns];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>; j<span style="color: #666666">&lt;</span>columns; j<span style="color: #666666">++</span>)
      data[i][j] <span style="color: #666666">=</span> m.data[i][j];
  }
}

Matrix<span style="color: #666666">::</span>Matrix(<span style="color: #B00040">int</span> num_Vectors, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">*</span> q){
  rows <span style="color: #666666">=</span> q[<span style="color: #666666">0</span>].Dimension();
  columns <span style="color: #666666">=</span> num_Vectors;

  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span><span style="color: #666666">*</span>[rows];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    data[i] <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[columns];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>; j<span style="color: #666666">&lt;</span>columns; j<span style="color: #666666">++</span>)
      data[i][j] <span style="color: #666666">=</span> q[j](i);
  }
}

Matrix<span style="color: #666666">::</span>Matrix(<span style="color: #B00040">int</span> rows1, <span style="color: #B00040">int</span> columns1, <span style="color: #B00040">double</span> <span style="color: #666666">**</span>rowptrs){
  rows <span style="color: #666666">=</span> rows1;
  columns <span style="color: #666666">=</span> columns1;

  data <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span><span style="color: #666666">*</span>[rows];

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
    data[i] <span style="color: #666666">=</span> rowptrs[i];
}


Matrix<span style="color: #666666">::~</span>Matrix(){
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
    <span style="color: #008000; font-weight: bold">delete</span>[] data[i];

  rows <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  columns <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #008000; font-weight: bold">delete</span>[] data;
}

<span style="color: #B00040">int</span> Matrix<span style="color: #666666">::</span>Rows() <span style="color: #008000; font-weight: bold">const</span>{
  <span style="color: #008000; font-weight: bold">return</span>(rows);
}  

<span style="color: #B00040">int</span> Matrix<span style="color: #666666">::</span>Columns() <span style="color: #008000; font-weight: bold">const</span>{
  <span style="color: #008000; font-weight: bold">return</span>(columns);
}  


<span style="color: #B00040">double</span> <span style="color: #666666">**</span>Matrix<span style="color: #666666">::</span>GetPointer(){
  <span style="color: #008000; font-weight: bold">return</span>(data);
}

<span style="color: #B00040">void</span> Matrix<span style="color: #666666">::</span>GetColumn(<span style="color: #B00040">int</span> col, Vector <span style="color: #666666">&amp;</span>x){
  x.Initialize(<span style="color: #666666">0.0</span>);
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> data[i][col];
}

<span style="color: #B00040">void</span> Matrix<span style="color: #666666">::</span>GetColumn(<span style="color: #B00040">int</span> col, Vector <span style="color: #666666">&amp;</span>x, <span style="color: #B00040">int</span> rowoffset){
  x.Initialize(<span style="color: #666666">0.0</span>);
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows<span style="color: #666666">-</span>rowoffset;i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> data[i<span style="color: #666666">+</span>rowoffset][col];
}

<span style="color: #B00040">void</span> Matrix<span style="color: #666666">::</span>PutColumn(<span style="color: #B00040">int</span> col, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>x){
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
    data[i][col] <span style="color: #666666">=</span> x(i);
}


<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span>Norm_linf(){
  <span style="color: #B00040">double</span> maxval <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>,sum;
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>)
      sum <span style="color: #666666">+=</span> fabs(data[i][j]);
    maxval <span style="color: #666666">=</span> (maxval <span style="color: #666666">&gt;</span> sum)<span style="color: #666666">?</span><span style="color: #A0A000">maxval</span>:sum;
  }
  <span style="color: #008000; font-weight: bold">return</span>(maxval);
}


<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span>Norm_l1(){
  <span style="color: #B00040">double</span> maxval <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>,sum;

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>){
    sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
      sum <span style="color: #666666">+=</span> fabs(data[i][j]);
    maxval <span style="color: #666666">=</span> (maxval <span style="color: #666666">&gt;</span> sum)<span style="color: #666666">?</span><span style="color: #A0A000">maxval</span>:sum;
  }
  <span style="color: #008000; font-weight: bold">return</span>(maxval);
}



Matrix<span style="color: #666666">&amp;</span> Matrix<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">=</span>(<span style="color: #008000; font-weight: bold">const</span> Matrix <span style="color: #666666">&amp;</span>m){
  <span style="color: #008000; font-weight: bold">if</span>( (rows <span style="color: #666666">==</span> m.rows) <span style="color: #666666">&amp;&amp;</span> (columns <span style="color: #666666">==</span> m.columns)){
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;</span>rows; i<span style="color: #666666">++</span>)
      <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>){
	data[i][j] <span style="color: #666666">=</span> m.data[i][j];
      }
  }
  <span style="color: #008000; font-weight: bold">else</span>
    cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Matrix Error: Cannot equate matrices of different sizes</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>;
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">*</span><span style="color: #008000; font-weight: bold">this</span>;
}

  
<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> j) <span style="color: #008000; font-weight: bold">const</span> {
  <span style="color: #008000; font-weight: bold">if</span>( (i<span style="color: #666666">&gt;=0</span>) <span style="color: #666666">&amp;&amp;</span> (j<span style="color: #666666">&gt;=0</span>) <span style="color: #666666">&amp;&amp;</span> (i<span style="color: #666666">&lt;</span>rows) <span style="color: #666666">&amp;&amp;</span> (j<span style="color: #666666">&lt;</span>columns))
    <span style="color: #008000; font-weight: bold">return</span>(data[i][j]);  
  <span style="color: #008000; font-weight: bold">else</span>
    cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Matrix Error: Invalid Matrix indices (&quot;</span> <span style="color: #666666">&lt;&lt;</span> i <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> j <span style="color: #666666">&lt;&lt;</span> 
      <span style="color: #BA2121">&quot;), for Matrix of size &quot;</span> <span style="color: #666666">&lt;&lt;</span> rows <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; X &quot;</span> <span style="color: #666666">&lt;&lt;</span> columns <span style="color: #666666">&lt;&lt;</span> endl;
  <span style="color: #008000; font-weight: bold">return</span>((<span style="color: #B00040">double</span>)<span style="color: #666666">0</span>);
}
  

<span style="color: #B00040">double</span><span style="color: #666666">&amp;</span> Matrix<span style="color: #666666">::</span><span style="color: #008000; font-weight: bold">operator</span>()(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> i, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">int</span> j) {
  <span style="color: #008000; font-weight: bold">if</span>( (i<span style="color: #666666">&gt;=0</span>) <span style="color: #666666">&amp;&amp;</span> (j<span style="color: #666666">&gt;=0</span>) <span style="color: #666666">&amp;&amp;</span> (i<span style="color: #666666">&lt;</span>rows) <span style="color: #666666">&amp;&amp;</span> (j<span style="color: #666666">&lt;</span>columns))
    <span style="color: #008000; font-weight: bold">return</span>(data[i][j]);  
  <span style="color: #008000; font-weight: bold">else</span>
    cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Matrix Error: Invalid Matrix indices (&quot;</span> <span style="color: #666666">&lt;&lt;</span> i <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;,&quot;</span> <span style="color: #666666">&lt;&lt;</span> j <span style="color: #666666">&lt;&lt;</span> 
      <span style="color: #BA2121">&quot;), for Matrix of size &quot;</span> <span style="color: #666666">&lt;&lt;</span> rows <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; X &quot;</span> <span style="color: #666666">&lt;&lt;</span> columns <span style="color: #666666">&lt;&lt;</span> endl;;
  <span style="color: #008000; font-weight: bold">return</span>(data[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]);
}


<span style="color: #B00040">void</span> Matrix<span style="color: #666666">::</span>Print() <span style="color: #008000; font-weight: bold">const</span>{
  cout <span style="color: #666666">&lt;&lt;</span> endl;


  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;[ &quot;</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    cout <span style="color: #666666">&lt;&lt;</span> data[i][<span style="color: #666666">0</span>];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=1</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>)
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; &quot;</span> <span style="color: #666666">&lt;&lt;</span> data[i][j];
    <span style="color: #008000; font-weight: bold">if</span>(i<span style="color: #666666">!=</span>(rows<span style="color: #666666">-1</span>))
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>;
  }
  cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot; ]&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
}


<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span>MaxModInRow(<span style="color: #B00040">int</span> row){
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>columns;i<span style="color: #666666">++</span>)
    maxv <span style="color: #666666">=</span> (fabs(data[row][i])<span style="color: #666666">&gt;</span>maxv)<span style="color: #666666">?</span>fabs(data[row][i])<span style="color: #666666">:</span>maxv;

  <span style="color: #008000; font-weight: bold">return</span> maxv;
}

<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span>MaxModInRow(<span style="color: #B00040">int</span> row, <span style="color: #B00040">int</span> starting_column){
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=</span>starting_column;i<span style="color: #666666">&lt;</span>columns;i<span style="color: #666666">++</span>)
    maxv <span style="color: #666666">=</span> (fabs(data[row][i])<span style="color: #666666">&gt;</span>maxv)<span style="color: #666666">?</span>fabs(data[row][i])<span style="color: #666666">:</span>maxv;

  <span style="color: #008000; font-weight: bold">return</span> maxv;
}

<span style="color: #B00040">int</span> Matrix<span style="color: #666666">::</span>MaxModInRowindex(<span style="color: #B00040">int</span> row){
  <span style="color: #B00040">int</span> maxvindex <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>columns;i<span style="color: #666666">++</span>){
    <span style="color: #008000; font-weight: bold">if</span>(maxv <span style="color: #666666">&lt;</span> fabs(data[row][i])){
      maxv <span style="color: #666666">=</span> fabs(data[row][i]);
      maxvindex <span style="color: #666666">=</span> i;
    }
  }

  <span style="color: #008000; font-weight: bold">return</span> maxvindex;
}

<span style="color: #B00040">int</span> Matrix<span style="color: #666666">::</span>MaxModInRowindex(<span style="color: #B00040">int</span> row, <span style="color: #B00040">int</span> starting_column){
  <span style="color: #B00040">int</span> maxvindex <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=</span>starting_column;i<span style="color: #666666">&lt;</span>columns;i<span style="color: #666666">++</span>){
    <span style="color: #008000; font-weight: bold">if</span>(maxv <span style="color: #666666">&lt;</span> fabs(data[row][i])){
      maxv <span style="color: #666666">=</span> fabs(data[row][i]);
      maxvindex <span style="color: #666666">=</span> i;
    }
  }
  
  <span style="color: #008000; font-weight: bold">return</span> maxvindex;
}

<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span>MaxModInColumn(<span style="color: #B00040">int</span> column){
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
    maxv <span style="color: #666666">=</span> (fabs(data[i][column])<span style="color: #666666">&gt;</span>maxv)<span style="color: #666666">?</span>fabs(data[i][column])<span style="color: #666666">:</span>maxv;

  <span style="color: #008000; font-weight: bold">return</span> maxv;
}

<span style="color: #B00040">double</span> Matrix<span style="color: #666666">::</span>MaxModInColumn(<span style="color: #B00040">int</span> column, <span style="color: #B00040">int</span> starting_row){
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=</span>starting_row;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>)
    maxv <span style="color: #666666">=</span> (fabs(data[i][column])<span style="color: #666666">&gt;</span>maxv)<span style="color: #666666">?</span>fabs(data[i][column])<span style="color: #666666">:</span>maxv;

  <span style="color: #008000; font-weight: bold">return</span> maxv;
}

<span style="color: #B00040">int</span> Matrix<span style="color: #666666">::</span>MaxModInColumnindex(<span style="color: #B00040">int</span> column){
  <span style="color: #B00040">int</span> maxvindex <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    <span style="color: #008000; font-weight: bold">if</span>(maxv <span style="color: #666666">&lt;</span> fabs(data[i][column])){
      maxv <span style="color: #666666">=</span> fabs(data[i][column]);
      maxvindex <span style="color: #666666">=</span> i;
    }
  }

  <span style="color: #008000; font-weight: bold">return</span> maxvindex;
}

<span style="color: #B00040">int</span> Matrix<span style="color: #666666">::</span>MaxModInColumnindex(<span style="color: #B00040">int</span> column, <span style="color: #B00040">int</span> starting_column){
  <span style="color: #B00040">int</span> maxvindex <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #B00040">double</span> maxv <span style="color: #666666">=</span> <span style="color: #666666">-1.0e+10</span>;

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=</span>starting_column;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    <span style="color: #008000; font-weight: bold">if</span>(maxv <span style="color: #666666">&lt;</span> fabs(data[i][column])){
      maxv <span style="color: #666666">=</span> fabs(data[i][column]);
      maxvindex <span style="color: #666666">=</span> i;
    }
  }
  
  <span style="color: #008000; font-weight: bold">return</span> maxvindex;
}

<span style="color: #B00040">void</span> Matrix<span style="color: #666666">::</span>RowSwap(<span style="color: #B00040">int</span> row1, <span style="color: #B00040">int</span> row2){
  <span style="color: #B00040">double</span> <span style="color: #666666">*</span> tmp <span style="color: #666666">=</span> data[row1];
  data[row1] <span style="color: #666666">=</span> data[row2];
  data[row2] <span style="color: #666666">=</span> tmp;
}



<span style="color: #408080; font-style: italic">/****************************************************************/</span>
<span style="color: #408080; font-style: italic">/*                 Operator Definitions                         */</span>
<span style="color: #408080; font-style: italic">/****************************************************************/</span>


Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">-</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v){
  Vector x(v.Dimension());
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>v.Dimension();i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> <span style="color: #666666">-</span>v(i);
  <span style="color: #008000; font-weight: bold">return</span> x;
}


Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">+</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v1, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v2){
  <span style="color: #B00040">int</span> min_dim <span style="color: #666666">=</span> min_dimension(v1,v2);
  Vector <span style="color: #0000FF">x</span>(min_dim);
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>min_dim;i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> v1(i) <span style="color: #666666">+</span> v2(i);
  <span style="color: #008000; font-weight: bold">return</span> x;
}


Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">-</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v1, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v2){
  <span style="color: #B00040">int</span> min_dim <span style="color: #666666">=</span> min_dimension(v1,v2);
  Vector <span style="color: #0000FF">x</span>(min_dim);
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>min_dim;i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> v1(i) <span style="color: #666666">-</span> v2(i);
  <span style="color: #008000; font-weight: bold">return</span> x;
}


Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">/</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> s) {
  Vector x(v.Dimension());
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>v.Dimension();i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> v(i)<span style="color: #666666">/</span>s;
  <span style="color: #008000; font-weight: bold">return</span> x;
}



Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span>(<span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> s, <span style="color: #008000; font-weight: bold">const</span> Vector <span style="color: #666666">&amp;</span>v) {
  Vector x(v.Dimension());
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>v.Dimension();i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> s<span style="color: #666666">*</span>v(i);
  <span style="color: #008000; font-weight: bold">return</span> x;
}


Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span>(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v, <span style="color: #008000; font-weight: bold">const</span> <span style="color: #B00040">double</span> s) {
  Vector x(v.Dimension());
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>v.Dimension();i<span style="color: #666666">++</span>)
    x(i) <span style="color: #666666">=</span> s<span style="color: #666666">*</span>v(i);
  <span style="color: #008000; font-weight: bold">return</span> x;
}

Vector <span style="color: #008000; font-weight: bold">operator</span><span style="color: #666666">*</span>(<span style="color: #008000; font-weight: bold">const</span> Matrix<span style="color: #666666">&amp;</span> A, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> x){
  <span style="color: #B00040">int</span> rows <span style="color: #666666">=</span> A.Rows(), columns <span style="color: #666666">=</span> A.Columns();
  <span style="color: #B00040">int</span> dim <span style="color: #666666">=</span> x.Dimension();
  Vector <span style="color: #0000FF">b</span>(dim);
  
  <span style="color: #008000; font-weight: bold">if</span>(columns <span style="color: #666666">!=</span> dim){
    cerr <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Invalid dimensions given in matrix-vector multiply&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
    <span style="color: #008000; font-weight: bold">return</span>(b);
  }
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>rows;i<span style="color: #666666">++</span>){
    b(i) <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>columns;j<span style="color: #666666">++</span>){
      b(i) <span style="color: #666666">+=</span> A(i,j)<span style="color: #666666">*</span>x(j);
    }
  }
  
  <span style="color: #008000; font-weight: bold">return</span> b;
}


<span style="color: #408080; font-style: italic">/****************************************************************/</span>
<span style="color: #408080; font-style: italic">/*                 Function Definitions                         */</span>
<span style="color: #408080; font-style: italic">/****************************************************************/</span>

<span style="color: #B00040">int</span> min_dimension(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v1, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v2){
  <span style="color: #B00040">int</span> min_dim <span style="color: #666666">=</span> (v1.Dimension()<span style="color: #666666">&lt;</span>v2.Dimension())<span style="color: #666666">?</span>v1.Dimension()<span style="color: #666666">:</span>v2.Dimension();
  <span style="color: #008000; font-weight: bold">return</span>(min_dim);
}


<span style="color: #B00040">double</span> dot(<span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> u, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v){
  <span style="color: #B00040">double</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  <span style="color: #B00040">int</span> min_dim <span style="color: #666666">=</span> min_dimension(u,v);

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>min_dim;i<span style="color: #666666">++</span>)
    sum <span style="color: #666666">+=</span> u(i)<span style="color: #666666">*</span>v(i);
  
  <span style="color: #008000; font-weight: bold">return</span> sum; 
}


<span style="color: #B00040">double</span> dot(<span style="color: #B00040">int</span> N, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> u, <span style="color: #008000; font-weight: bold">const</span> Vector<span style="color: #666666">&amp;</span> v){
  <span style="color: #B00040">double</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;

  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>N;i<span style="color: #666666">++</span>)
    sum <span style="color: #666666">+=</span> u(i)<span style="color: #666666">*</span>v(i);
  
  <span style="color: #008000; font-weight: bold">return</span> sum;
}


<span style="color: #B00040">double</span> dot(<span style="color: #B00040">int</span> N, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>a, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>b){
  <span style="color: #B00040">double</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>N;i<span style="color: #666666">++</span>)
    sum <span style="color: #666666">+=</span> a[i]<span style="color: #666666">*</span>b[i];

  <span style="color: #008000; font-weight: bold">return</span> sum;
}


<span style="color: #408080; font-style: italic">/*******************************/</span>
<span style="color: #408080; font-style: italic">/*   Log base 2 of a number    */</span>
<span style="color: #408080; font-style: italic">/*******************************/</span>

<span style="color: #B00040">double</span> log2(<span style="color: #B00040">double</span> x){
  <span style="color: #008000; font-weight: bold">return</span>(log(x)<span style="color: #666666">/</span>log(<span style="color: #666666">2.0</span>));
}

<span style="color: #B00040">void</span> Swap(<span style="color: #B00040">double</span> <span style="color: #666666">&amp;</span>a, <span style="color: #B00040">double</span> <span style="color: #666666">&amp;</span>b){
  <span style="color: #B00040">double</span> tmp <span style="color: #666666">=</span> a;
  a <span style="color: #666666">=</span> b;
  b <span style="color: #666666">=</span> tmp;
}

<span style="color: #B00040">double</span> Sign(<span style="color: #B00040">double</span> x){
  <span style="color: #B00040">double</span> xs;

  xs <span style="color: #666666">=</span> (x<span style="color: #666666">&gt;=0.0</span>)<span style="color: #666666">?1.0:-1.0</span>;

  <span style="color: #008000; font-weight: bold">return</span> xs;
}

<span style="color: #408080; font-style: italic">//GammaF function valid for x integer, or x (integer+0.5)</span>
<span style="color: #B00040">double</span> GammaF(<span style="color: #B00040">double</span> x){
  <span style="color: #B00040">double</span> gamma <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>;
  
  <span style="color: #008000; font-weight: bold">if</span> (x <span style="color: #666666">==</span> <span style="color: #666666">-0.5</span>) 
    gamma <span style="color: #666666">=</span> <span style="color: #666666">-2.0*</span>sqrt(M_PI);
  <span style="color: #008000; font-weight: bold">else</span> <span style="color: #0000FF">if</span> (<span style="color: #666666">!</span>x) <span style="color: #008000; font-weight: bold">return</span> gamma;
  <span style="color: #008000; font-weight: bold">else</span> <span style="color: #0000FF">if</span> ((x<span style="color: #666666">-</span>(<span style="color: #B00040">int</span>)x) <span style="color: #666666">==</span> <span style="color: #666666">0.5</span>){ 
    <span style="color: #B00040">int</span> n <span style="color: #666666">=</span> (<span style="color: #B00040">int</span>) x;
    <span style="color: #B00040">double</span> tmp <span style="color: #666666">=</span> x;
    
    gamma <span style="color: #666666">=</span> sqrt(M_PI);
    <span style="color: #008000; font-weight: bold">while</span>(n<span style="color: #666666">--</span>){
      tmp   <span style="color: #666666">-=</span> <span style="color: #666666">1.0</span>;
      gamma <span style="color: #666666">*=</span> tmp;
    }
  }
  <span style="color: #008000; font-weight: bold">else</span> <span style="color: #0000FF">if</span> ((x<span style="color: #666666">-</span>(<span style="color: #B00040">int</span>)x) <span style="color: #666666">==</span> <span style="color: #666666">0.0</span>){
    <span style="color: #B00040">int</span> n <span style="color: #666666">=</span> (<span style="color: #B00040">int</span>) x;
    <span style="color: #B00040">double</span> tmp <span style="color: #666666">=</span> x;
    
    <span style="color: #008000; font-weight: bold">while</span>(<span style="color: #666666">--</span>n){
      tmp   <span style="color: #666666">-=</span> <span style="color: #666666">1.0</span>;
      gamma <span style="color: #666666">*=</span> tmp;
    }
  }  
  
  <span style="color: #008000; font-weight: bold">return</span> gamma;
}


<span style="color: #B00040">int</span> Factorial(<span style="color: #B00040">int</span> n){
  <span style="color: #B00040">int</span> value<span style="color: #666666">=1</span>;
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=</span>n;i<span style="color: #666666">&gt;0</span>;i<span style="color: #666666">--</span>)
    value <span style="color: #666666">=</span> value<span style="color: #666666">*</span>i;

  <span style="color: #008000; font-weight: bold">return</span> value;
}

<span style="color: #B00040">double</span> <span style="color: #666666">**</span> CreateMatrix(<span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n){
  <span style="color: #B00040">double</span> <span style="color: #666666">**</span> mat;
  mat <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span><span style="color: #666666">*</span>[m];
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>m;i<span style="color: #666666">++</span>){
    mat[i] <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span>[n];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>m;j<span style="color: #666666">++</span>)
      mat[i][j] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> mat;
}

<span style="color: #B00040">int</span> <span style="color: #666666">**</span> ICreateMatrix(<span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n){
  <span style="color: #B00040">int</span> <span style="color: #666666">**</span> mat;
  mat <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">int</span><span style="color: #666666">*</span>[m];
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>m;i<span style="color: #666666">++</span>){
    mat[i] <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">int</span>[n];
    <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> j<span style="color: #666666">=0</span>;j<span style="color: #666666">&lt;</span>m;j<span style="color: #666666">++</span>)
      mat[i][j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> mat;
}

<span style="color: #B00040">void</span> DestroyMatrix(<span style="color: #B00040">double</span> <span style="color: #666666">**</span> mat, <span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n){
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>m;i<span style="color: #666666">++</span>)
    <span style="color: #008000; font-weight: bold">delete</span>[] mat[i];
  <span style="color: #008000; font-weight: bold">delete</span>[] mat;
}

<span style="color: #B00040">void</span> IDestroyMatrix(<span style="color: #B00040">int</span> <span style="color: #666666">**</span> mat, <span style="color: #B00040">int</span> m, <span style="color: #B00040">int</span> n){
  <span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>m;i<span style="color: #666666">++</span>)
    <span style="color: #008000; font-weight: bold">delete</span>[] mat[i];
  <span style="color: #008000; font-weight: bold">delete</span>[] mat;
}
</pre></div>
<p>

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._learningcpp-bs000.html">&laquo;</a></li>
  <li><a href="._learningcpp-bs000.html">1</a></li>
  <li class="active"><a href="._learningcpp-bs001.html">2</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

